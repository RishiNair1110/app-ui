{"ast":null,"code":"/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\nfunction backtrace(node) {\n  var path = [[node.x, node.y]];\n\n  while (node.parent) {\n    node = node.parent;\n    path.push([node.x, node.y]);\n  }\n\n  return path.reverse();\n}\n\nexports.backtrace = backtrace;\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\n\nfunction biBacktrace(nodeA, nodeB) {\n  var pathA = backtrace(nodeA),\n      pathB = backtrace(nodeB);\n  return pathA.concat(pathB.reverse());\n}\n\nexports.biBacktrace = biBacktrace;\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\n\nfunction pathLength(path) {\n  var i,\n      sum = 0,\n      a,\n      b,\n      dx,\n      dy;\n\n  for (i = 1; i < path.length; ++i) {\n    a = path[i - 1];\n    b = path[i];\n    dx = a[0] - b[0];\n    dy = a[1] - b[1];\n    sum += Math.sqrt(dx * dx + dy * dy);\n  }\n\n  return sum;\n}\n\nexports.pathLength = pathLength;\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\n\nfunction interpolate(x0, y0, x1, y1) {\n  var abs = Math.abs,\n      line = [],\n      sx,\n      sy,\n      dx,\n      dy,\n      err,\n      e2;\n  dx = abs(x1 - x0);\n  dy = abs(y1 - y0);\n  sx = x0 < x1 ? 1 : -1;\n  sy = y0 < y1 ? 1 : -1;\n  err = dx - dy;\n\n  while (true) {\n    line.push([x0, y0]);\n\n    if (x0 === x1 && y0 === y1) {\n      break;\n    }\n\n    e2 = 2 * err;\n\n    if (e2 > -dy) {\n      err = err - dy;\n      x0 = x0 + sx;\n    }\n\n    if (e2 < dx) {\n      err = err + dx;\n      y0 = y0 + sy;\n    }\n  }\n\n  return line;\n}\n\nexports.interpolate = interpolate;\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\n\nfunction expandPath(path) {\n  var expanded = [],\n      len = path.length,\n      coord0,\n      coord1,\n      interpolated,\n      interpolatedLen,\n      i,\n      j;\n\n  if (len < 2) {\n    return expanded;\n  }\n\n  for (i = 0; i < len - 1; ++i) {\n    coord0 = path[i];\n    coord1 = path[i + 1];\n    interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\n    interpolatedLen = interpolated.length;\n\n    for (j = 0; j < interpolatedLen - 1; ++j) {\n      expanded.push(interpolated[j]);\n    }\n  }\n\n  expanded.push(path[len - 1]);\n  return expanded;\n}\n\nexports.expandPath = expandPath;\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\n\nfunction smoothenPath(grid, path) {\n  var len = path.length,\n      x0 = path[0][0],\n      // path start x\n  y0 = path[0][1],\n      // path start y\n  x1 = path[len - 1][0],\n      // path end x\n  y1 = path[len - 1][1],\n      // path end y\n  sx,\n      sy,\n      // current start coordinate\n  ex,\n      ey,\n      // current end coordinate\n  newPath,\n      i,\n      j,\n      coord,\n      line,\n      testCoord,\n      blocked;\n  sx = x0;\n  sy = y0;\n  newPath = [[sx, sy]];\n\n  for (i = 2; i < len; ++i) {\n    coord = path[i];\n    ex = coord[0];\n    ey = coord[1];\n    line = interpolate(sx, sy, ex, ey);\n    blocked = false;\n\n    for (j = 1; j < line.length; ++j) {\n      testCoord = line[j];\n\n      if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\n        blocked = true;\n        break;\n      }\n    }\n\n    if (blocked) {\n      lastValidCoord = path[i - 1];\n      newPath.push(lastValidCoord);\n      sx = lastValidCoord[0];\n      sy = lastValidCoord[1];\n    }\n  }\n\n  newPath.push([x1, y1]);\n  return newPath;\n}\n\nexports.smoothenPath = smoothenPath;\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\n\nfunction compressPath(path) {\n  // nothing to compress\n  if (path.length < 3) {\n    return path;\n  }\n\n  var compressed = [],\n      sx = path[0][0],\n      // start x\n  sy = path[0][1],\n      // start y\n  px = path[1][0],\n      // second point x\n  py = path[1][1],\n      // second point y\n  dx = px - sx,\n      // direction between the two points\n  dy = py - sy,\n      // direction between the two points\n  lx,\n      ly,\n      ldx,\n      ldy,\n      sq,\n      i; // normalize the direction\n\n  sq = Math.sqrt(dx * dx + dy * dy);\n  dx /= sq;\n  dy /= sq; // start the new path\n\n  compressed.push([sx, sy]);\n\n  for (i = 2; i < path.length; i++) {\n    // store the last point\n    lx = px;\n    ly = py; // store the last direction\n\n    ldx = dx;\n    ldy = dy; // next point\n\n    px = path[i][0];\n    py = path[i][1]; // next direction\n\n    dx = px - lx;\n    dy = py - ly; // normalize\n\n    sq = Math.sqrt(dx * dx + dy * dy);\n    dx /= sq;\n    dy /= sq; // if the direction has changed, store the point\n\n    if (dx !== ldx || dy !== ldy) {\n      compressed.push([lx, ly]);\n    }\n  } // store the last point\n\n\n  compressed.push([px, py]);\n  return compressed;\n}\n\nexports.compressPath = compressPath;","map":{"version":3,"sources":["C:/Users/nairr/app-ui/app-ui/node_modules/pathfinding/src/core/Util.js"],"names":["backtrace","node","path","x","y","parent","push","reverse","exports","biBacktrace","nodeA","nodeB","pathA","pathB","concat","pathLength","i","sum","a","b","dx","dy","length","Math","sqrt","interpolate","x0","y0","x1","y1","abs","line","sx","sy","err","e2","expandPath","expanded","len","coord0","coord1","interpolated","interpolatedLen","j","smoothenPath","grid","ex","ey","newPath","coord","testCoord","blocked","isWalkableAt","lastValidCoord","compressPath","compressed","px","py","lx","ly","ldx","ldy","sq"],"mappings":"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","sourcesContent":["/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PanAndZoomCanvasAction = void 0;\n\nconst Action_1 = require(\"../core-actions/Action\");\n\nclass PanAndZoomCanvasAction extends Action_1.Action {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      type: Action_1.InputType.MOUSE_WHEEL,\n      fire: actionEvent => {\n        const {\n          event\n        } = actionEvent; // we can block layer rendering because we are only targeting the transforms\n\n        for (let layer of this.engine.getModel().getLayers()) {\n          layer.allowRepaint(false);\n        }\n\n        const model = this.engine.getModel();\n        event.stopPropagation();\n\n        if (event.ctrlKey) {\n          // Pinch and zoom gesture\n          const oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\n          let scrollDelta = options.inverseZoom ? event.deltaY : -event.deltaY;\n          scrollDelta /= 3;\n\n          if (model.getZoomLevel() + scrollDelta > 10) {\n            model.setZoomLevel(model.getZoomLevel() + scrollDelta);\n          }\n\n          const zoomFactor = model.getZoomLevel() / 100;\n          const boundingRect = event.currentTarget.getBoundingClientRect();\n          const clientWidth = boundingRect.width;\n          const clientHeight = boundingRect.height; // compute difference between rect before and after scroll\n\n          const widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n          const heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor; // compute mouse coords relative to canvas\n\n          const clientX = event.clientX - boundingRect.left;\n          const clientY = event.clientY - boundingRect.top; // compute width and height increment factor\n\n          const xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\n          const yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\n          model.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\n        } else {\n          // Pan gesture\n          let yDelta = options.inverseZoom ? -event.deltaY : event.deltaY;\n          let xDelta = options.inverseZoom ? -event.deltaX : event.deltaX;\n          model.setOffset(model.getOffsetX() - xDelta, model.getOffsetY() - yDelta);\n        }\n\n        this.engine.repaintCanvas(); // re-enable rendering\n\n        for (let layer of this.engine.getModel().getLayers()) {\n          layer.allowRepaint(true);\n        }\n      }\n    });\n  }\n\n}\n\nexports.PanAndZoomCanvasAction = PanAndZoomCanvasAction;","map":{"version":3,"mappings":"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","names":["PanAndZoomCanvasAction","Action_1","constructor","options","type","MOUSE_WHEEL","fire","actionEvent","event","layer","engine","getModel","getLayers","allowRepaint","model","stopPropagation","ctrlKey","oldZoomFactor","getZoomLevel","scrollDelta","inverseZoom","deltaY","setZoomLevel","zoomFactor","boundingRect","currentTarget","getBoundingClientRect","clientWidth","width","clientHeight","height","widthDiff","heightDiff","clientX","left","clientY","top","xFactor","getOffsetX","yFactor","getOffsetY","setOffset","yDelta","xDelta","deltaX","repaintCanvas","exports"],"sources":["C:\\Users\\nairr\\app-ui\\app-ui\\node_modules\\@projectstorm\\react-canvas-core\\src\\actions\\PanAndZoomCanvasAction.ts"],"sourcesContent":["import { WheelEvent } from 'react';\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\n\nexport interface PanAndZoomCanvasActionOptions {\n\tinverseZoom?: boolean;\n}\n\nexport class PanAndZoomCanvasAction extends Action {\n\tconstructor(options: PanAndZoomCanvasActionOptions = {}) {\n\t\tsuper({\n\t\t\ttype: InputType.MOUSE_WHEEL,\n\t\t\tfire: (actionEvent: ActionEvent<WheelEvent>) => {\n\t\t\t\tconst { event } = actionEvent;\n\t\t\t\t// we can block layer rendering because we are only targeting the transforms\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\n\t\t\t\t\tlayer.allowRepaint(false);\n\t\t\t\t}\n\n\t\t\t\tconst model = this.engine.getModel();\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tif (event.ctrlKey) {\n\t\t\t\t\t// Pinch and zoom gesture\n\t\t\t\t\tconst oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\n\n\t\t\t\t\tlet scrollDelta = options.inverseZoom ? event.deltaY : -event.deltaY;\n\t\t\t\t\tscrollDelta /= 3;\n\n\t\t\t\t\tif (model.getZoomLevel() + scrollDelta > 10) {\n\t\t\t\t\t\tmodel.setZoomLevel(model.getZoomLevel() + scrollDelta);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst zoomFactor = model.getZoomLevel() / 100;\n\n\t\t\t\t\tconst boundingRect = event.currentTarget.getBoundingClientRect();\n\t\t\t\t\tconst clientWidth = boundingRect.width;\n\t\t\t\t\tconst clientHeight = boundingRect.height;\n\t\t\t\t\t// compute difference between rect before and after scroll\n\t\t\t\t\tconst widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n\t\t\t\t\tconst heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\n\t\t\t\t\t// compute mouse coords relative to canvas\n\t\t\t\t\tconst clientX = event.clientX - boundingRect.left;\n\t\t\t\t\tconst clientY = event.clientY - boundingRect.top;\n\n\t\t\t\t\t// compute width and height increment factor\n\t\t\t\t\tconst xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\n\t\t\t\t\tconst yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\n\n\t\t\t\t\tmodel.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\n\t\t\t\t} else {\n\t\t\t\t\t// Pan gesture\n\t\t\t\t\tlet yDelta = options.inverseZoom ? -event.deltaY : event.deltaY;\n\t\t\t\t\tlet xDelta = options.inverseZoom ? -event.deltaX : event.deltaX;\n\t\t\t\t\tmodel.setOffset(model.getOffsetX() - xDelta, model.getOffsetY() - yDelta);\n\t\t\t\t}\n\t\t\t\tthis.engine.repaintCanvas();\n\n\t\t\t\t// re-enable rendering\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\n\t\t\t\t\tlayer.allowRepaint(true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}
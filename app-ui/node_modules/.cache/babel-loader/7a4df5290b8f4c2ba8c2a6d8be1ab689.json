{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.State = void 0;\n\nconst Action_1 = require(\"../core-actions/Action\");\n\nconst _ = require(\"lodash\");\n\nclass State {\n  constructor(options) {\n    this.actions = [];\n    this.keys = [];\n    this.childStates = [];\n    this.options = options;\n  }\n\n  setEngine(engine) {\n    this.engine = engine;\n  }\n\n  getOptions() {\n    return this.options;\n  }\n\n  eject() {\n    this.engine.getStateMachine().popState();\n  }\n\n  transitionWithEvent(state, event) {\n    this.engine.getStateMachine().pushState(state);\n    this.engine.getActionEventBus().fireAction(event);\n  }\n\n  registerAction(action) {\n    this.actions.push(action);\n  }\n\n  tryActivateParentState(keys) {\n    if (this.keys.length > 0 && !this.isKeysFullfilled(keys)) {\n      this.eject();\n      return true;\n    }\n\n    return false;\n  }\n\n  tryActivateChildState(keys) {\n    const state = this.findStateToActivate(keys);\n\n    if (state) {\n      this.engine.getStateMachine().pushState(state);\n      return true;\n    }\n\n    return false;\n  }\n\n  findStateToActivate(keys) {\n    for (let child of this.childStates) {\n      if (child.isKeysFullfilled(keys)) {\n        return child;\n      }\n    }\n\n    return null;\n  }\n\n  isKeysFullfilled(keys) {\n    return _.intersection(this.keys, keys).length === this.keys.length;\n  }\n\n  activated(previous) {\n    const keys = this.engine.getActionEventBus().getKeys();\n\n    if (this.tryActivateParentState(keys) || this.tryActivateChildState(keys)) {\n      return;\n    } // perhaps we need to pop again?\n\n\n    this.handler1 = this.engine.getActionEventBus().registerAction(new Action_1.Action({\n      type: Action_1.InputType.KEY_DOWN,\n      fire: () => {\n        this.tryActivateChildState(this.engine.getActionEventBus().getKeys());\n      }\n    }));\n    this.handler2 = this.engine.getActionEventBus().registerAction(new Action_1.Action({\n      type: Action_1.InputType.KEY_UP,\n      fire: () => {\n        this.tryActivateParentState(this.engine.getActionEventBus().getKeys());\n      }\n    }));\n\n    for (let action of this.actions) {\n      this.engine.getActionEventBus().registerAction(action);\n    }\n  }\n\n  deactivated(next) {\n    if (this.handler1) {\n      this.handler1();\n    }\n\n    if (this.handler2) {\n      this.handler2();\n    } // if this happens, we are going into heirachial state machine mode\n\n\n    for (let action of this.actions) {\n      this.engine.getActionEventBus().deregisterAction(action);\n    }\n  }\n\n}\n\nexports.State = State;","map":{"version":3,"mappings":";;;;;;;AACA;;AAEA;;AAMA,MAAsBA,KAAtB,CAA2B;AAU1BC,cAAYC,OAAZ,EAAiC;AAChC,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,IAAL,GAAY,EAAZ;AACA,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKH,OAAL,GAAeA,OAAf;AACA;;AAEDI,WAAS,CAACC,MAAD,EAAU;AAClB,SAAKA,MAAL,GAAcA,MAAd;AACA;;AAEDC,YAAU;AACT,WAAO,KAAKN,OAAZ;AACA;;AAEDO,OAAK;AACJ,SAAKF,MAAL,CAAYG,eAAZ,GAA8BC,QAA9B;AACA;;AAEDC,qBAAmB,CAACC,KAAD,EAAeC,KAAf,EAAiD;AACnE,SAAKP,MAAL,CAAYG,eAAZ,GAA8BK,SAA9B,CAAwCF,KAAxC;AACA,SAAKN,MAAL,CAAYS,iBAAZ,GAAgCC,UAAhC,CAA2CH,KAA3C;AACA;;AAEDI,gBAAc,CAACC,MAAD,EAAe;AAC5B,SAAKhB,OAAL,CAAaiB,IAAb,CAAkBD,MAAlB;AACA;;AAEDE,wBAAsB,CAACjB,IAAD,EAAe;AACpC,QAAI,KAAKA,IAAL,CAAUkB,MAAV,GAAmB,CAAnB,IAAwB,CAAC,KAAKC,gBAAL,CAAsBnB,IAAtB,CAA7B,EAA0D;AACzD,WAAKK,KAAL;AACA,aAAO,IAAP;AACA;;AACD,WAAO,KAAP;AACA;;AAEDe,uBAAqB,CAACpB,IAAD,EAAe;AACnC,UAAMS,KAAK,GAAG,KAAKY,mBAAL,CAAyBrB,IAAzB,CAAd;;AACA,QAAIS,KAAJ,EAAW;AACV,WAAKN,MAAL,CAAYG,eAAZ,GAA8BK,SAA9B,CAAwCF,KAAxC;AACA,aAAO,IAAP;AACA;;AACD,WAAO,KAAP;AACA;;AAEDY,qBAAmB,CAACrB,IAAD,EAAe;AACjC,SAAK,IAAIsB,KAAT,IAAkB,KAAKrB,WAAvB,EAAoC;AACnC,UAAIqB,KAAK,CAACH,gBAAN,CAAuBnB,IAAvB,CAAJ,EAAkC;AACjC,eAAOsB,KAAP;AACA;AACD;;AAED,WAAO,IAAP;AACA;;AAEDH,kBAAgB,CAACnB,IAAD,EAAe;AAC9B,WAAOuB,CAAC,CAACC,YAAF,CAAe,KAAKxB,IAApB,EAA0BA,IAA1B,EAAgCkB,MAAhC,KAA2C,KAAKlB,IAAL,CAAUkB,MAA5D;AACA;;AAEDO,WAAS,CAACC,QAAD,EAAgB;AACxB,UAAM1B,IAAI,GAAG,KAAKG,MAAL,CAAYS,iBAAZ,GAAgCe,OAAhC,EAAb;;AAEA,QAAI,KAAKV,sBAAL,CAA4BjB,IAA5B,KAAqC,KAAKoB,qBAAL,CAA2BpB,IAA3B,CAAzC,EAA2E;AAC1E;AACA,KALuB,CAOxB;;;AACA,SAAK4B,QAAL,GAAgB,KAAKzB,MAAL,CAAYS,iBAAZ,GAAgCE,cAAhC,CACf,IAAIe,eAAJ,CAAW;AACVC,UAAI,EAAED,mBAAUE,QADN;AAEVC,UAAI,EAAE,MAAK;AACV,aAAKZ,qBAAL,CAA2B,KAAKjB,MAAL,CAAYS,iBAAZ,GAAgCe,OAAhC,EAA3B;AACA;AAJS,KAAX,CADe,CAAhB;AASA,SAAKM,QAAL,GAAgB,KAAK9B,MAAL,CAAYS,iBAAZ,GAAgCE,cAAhC,CACf,IAAIe,eAAJ,CAAW;AACVC,UAAI,EAAED,mBAAUK,MADN;AAEVF,UAAI,EAAE,MAAK;AACV,aAAKf,sBAAL,CAA4B,KAAKd,MAAL,CAAYS,iBAAZ,GAAgCe,OAAhC,EAA5B;AACA;AAJS,KAAX,CADe,CAAhB;;AASA,SAAK,IAAIZ,MAAT,IAAmB,KAAKhB,OAAxB,EAAiC;AAChC,WAAKI,MAAL,CAAYS,iBAAZ,GAAgCE,cAAhC,CAA+CC,MAA/C;AACA;AACD;;AAEDoB,aAAW,CAACC,IAAD,EAAY;AACtB,QAAI,KAAKR,QAAT,EAAmB;AAClB,WAAKA,QAAL;AACA;;AACD,QAAI,KAAKK,QAAT,EAAmB;AAClB,WAAKA,QAAL;AACA,KANqB,CAOtB;;;AACA,SAAK,IAAIlB,MAAT,IAAmB,KAAKhB,OAAxB,EAAiC;AAChC,WAAKI,MAAL,CAAYS,iBAAZ,GAAgCyB,gBAAhC,CAAiDtB,MAAjD;AACA;AACD;;AA/GyB;;AAA3BuB","names":["State","constructor","options","actions","keys","childStates","setEngine","engine","getOptions","eject","getStateMachine","popState","transitionWithEvent","state","event","pushState","getActionEventBus","fireAction","registerAction","action","push","tryActivateParentState","length","isKeysFullfilled","tryActivateChildState","findStateToActivate","child","_","intersection","activated","previous","getKeys","handler1","Action_1","type","KEY_DOWN","fire","handler2","KEY_UP","deactivated","next","deregisterAction","exports"],"sources":["C:\\Users\\nairr\\app-ui\\app-ui\\node_modules\\@projectstorm\\react-canvas-core\\src\\core-state\\State.ts"],"sourcesContent":["import { CanvasEngine } from '../CanvasEngine';\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\nimport { SyntheticEvent } from 'react';\nimport * as _ from 'lodash';\n\nexport interface StateOptions {\n\tname: string;\n}\n\nexport abstract class State<E extends CanvasEngine = CanvasEngine> {\n\tprotected engine: E;\n\tprotected actions: Action[];\n\tprotected keys: string[];\n\tprotected options: StateOptions;\n\tprotected childStates: State[];\n\n\tprivate handler1;\n\tprivate handler2;\n\n\tconstructor(options: StateOptions) {\n\t\tthis.actions = [];\n\t\tthis.keys = [];\n\t\tthis.childStates = [];\n\t\tthis.options = options;\n\t}\n\n\tsetEngine(engine: E) {\n\t\tthis.engine = engine;\n\t}\n\n\tgetOptions() {\n\t\treturn this.options;\n\t}\n\n\teject() {\n\t\tthis.engine.getStateMachine().popState();\n\t}\n\n\ttransitionWithEvent(state: State, event: ActionEvent<SyntheticEvent>) {\n\t\tthis.engine.getStateMachine().pushState(state);\n\t\tthis.engine.getActionEventBus().fireAction(event);\n\t}\n\n\tregisterAction(action: Action) {\n\t\tthis.actions.push(action);\n\t}\n\n\ttryActivateParentState(keys: string[]) {\n\t\tif (this.keys.length > 0 && !this.isKeysFullfilled(keys)) {\n\t\t\tthis.eject();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\ttryActivateChildState(keys: string[]) {\n\t\tconst state = this.findStateToActivate(keys);\n\t\tif (state) {\n\t\t\tthis.engine.getStateMachine().pushState(state);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfindStateToActivate(keys: string[]) {\n\t\tfor (let child of this.childStates) {\n\t\t\tif (child.isKeysFullfilled(keys)) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tisKeysFullfilled(keys: string[]) {\n\t\treturn _.intersection(this.keys, keys).length === this.keys.length;\n\t}\n\n\tactivated(previous: State) {\n\t\tconst keys = this.engine.getActionEventBus().getKeys();\n\n\t\tif (this.tryActivateParentState(keys) || this.tryActivateChildState(keys)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// perhaps we need to pop again?\n\t\tthis.handler1 = this.engine.getActionEventBus().registerAction(\n\t\t\tnew Action({\n\t\t\t\ttype: InputType.KEY_DOWN,\n\t\t\t\tfire: () => {\n\t\t\t\t\tthis.tryActivateChildState(this.engine.getActionEventBus().getKeys());\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\tthis.handler2 = this.engine.getActionEventBus().registerAction(\n\t\t\tnew Action({\n\t\t\t\ttype: InputType.KEY_UP,\n\t\t\t\tfire: () => {\n\t\t\t\t\tthis.tryActivateParentState(this.engine.getActionEventBus().getKeys());\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\tfor (let action of this.actions) {\n\t\t\tthis.engine.getActionEventBus().registerAction(action);\n\t\t}\n\t}\n\n\tdeactivated(next: State) {\n\t\tif (this.handler1) {\n\t\t\tthis.handler1();\n\t\t}\n\t\tif (this.handler2) {\n\t\t\tthis.handler2();\n\t\t}\n\t\t// if this happens, we are going into heirachial state machine mode\n\t\tfor (let action of this.actions) {\n\t\t\tthis.engine.getActionEventBus().deregisterAction(action);\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}
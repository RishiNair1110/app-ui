{"ast":null,"code":"/**\r\n * @author imor / https://github.com/imor\r\n */\nvar Heap = require('heap');\n\nvar Util = require('../core/Util');\n\nvar Heuristic = require('../core/Heuristic');\n\nvar DiagonalMovement = require('../core/DiagonalMovement');\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\n\n\nfunction JumpPointFinderBase(opt) {\n  opt = opt || {};\n  this.heuristic = opt.heuristic || Heuristic.manhattan;\n  this.trackJumpRecursion = opt.trackJumpRecursion || false;\n}\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\n\n\nJumpPointFinderBase.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  var openList = this.openList = new Heap(function (nodeA, nodeB) {\n    return nodeA.f - nodeB.f;\n  }),\n      startNode = this.startNode = grid.getNodeAt(startX, startY),\n      endNode = this.endNode = grid.getNodeAt(endX, endY),\n      node;\n  this.grid = grid; // set the `g` and `f` value of the start node to be 0\n\n  startNode.g = 0;\n  startNode.f = 0; // push the start node into the open list\n\n  openList.push(startNode);\n  startNode.opened = true; // while the open list is not empty\n\n  while (!openList.empty()) {\n    // pop the position of node which has the minimum `f` value.\n    node = openList.pop();\n    node.closed = true;\n\n    if (node === endNode) {\n      return Util.expandPath(Util.backtrace(endNode));\n    }\n\n    this._identifySuccessors(node);\n  } // fail to find the path\n\n\n  return [];\n};\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\n\n\nJumpPointFinderBase.prototype._identifySuccessors = function (node) {\n  var grid = this.grid,\n      heuristic = this.heuristic,\n      openList = this.openList,\n      endX = this.endNode.x,\n      endY = this.endNode.y,\n      neighbors,\n      neighbor,\n      jumpPoint,\n      i,\n      l,\n      x = node.x,\n      y = node.y,\n      jx,\n      jy,\n      dx,\n      dy,\n      d,\n      ng,\n      jumpNode,\n      abs = Math.abs,\n      max = Math.max;\n  neighbors = this._findNeighbors(node);\n\n  for (i = 0, l = neighbors.length; i < l; ++i) {\n    neighbor = neighbors[i];\n    jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\n\n    if (jumpPoint) {\n      jx = jumpPoint[0];\n      jy = jumpPoint[1];\n      jumpNode = grid.getNodeAt(jx, jy);\n\n      if (jumpNode.closed) {\n        continue;\n      } // include distance, as parent may not be immediately adjacent:\n\n\n      d = Heuristic.octile(abs(jx - x), abs(jy - y));\n      ng = node.g + d; // next `g` value\n\n      if (!jumpNode.opened || ng < jumpNode.g) {\n        jumpNode.g = ng;\n        jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\n        jumpNode.f = jumpNode.g + jumpNode.h;\n        jumpNode.parent = node;\n\n        if (!jumpNode.opened) {\n          openList.push(jumpNode);\n          jumpNode.opened = true;\n        } else {\n          openList.updateItem(jumpNode);\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = JumpPointFinderBase;","map":{"version":3,"sources":["C:/Users/nairr/app-ui/app-ui/node_modules/pathfinding/src/finders/JumpPointFinderBase.js"],"names":["Heap","require","Util","Heuristic","DiagonalMovement","JumpPointFinderBase","opt","heuristic","manhattan","trackJumpRecursion","prototype","findPath","startX","startY","endX","endY","grid","openList","nodeA","nodeB","f","startNode","getNodeAt","endNode","node","g","push","opened","empty","pop","closed","expandPath","backtrace","_identifySuccessors","x","y","neighbors","neighbor","jumpPoint","i","l","jx","jy","dx","dy","d","ng","jumpNode","abs","Math","max","_findNeighbors","length","_jump","octile","h","parent","updateItem","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n"]},"metadata":{},"sourceType":"script"}
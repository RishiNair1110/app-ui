{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DragNewLinkState = void 0;\n\nconst react_canvas_core_1 = require(\"@projectstorm/react-canvas-core\");\n\nconst PortModel_1 = require(\"../entities/port/PortModel\");\n\nclass DragNewLinkState extends react_canvas_core_1.AbstractDisplacementState {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      name: 'drag-new-link'\n    });\n    this.config = Object.assign({\n      allowLooseLinks: true,\n      allowLinksFromLockedPorts: false\n    }, options);\n    this.registerAction(new react_canvas_core_1.Action({\n      type: react_canvas_core_1.InputType.MOUSE_DOWN,\n      fire: event => {\n        this.port = this.engine.getMouseElement(event.event);\n\n        if (!this.config.allowLinksFromLockedPorts && this.port.isLocked()) {\n          this.eject();\n          return;\n        }\n\n        this.link = this.port.createLinkModel(); // if no link is given, just eject the state\n\n        if (!this.link) {\n          this.eject();\n          return;\n        }\n\n        this.link.setSelected(true);\n        this.link.setSourcePort(this.port);\n        this.engine.getModel().addLink(this.link);\n        this.port.reportPosition();\n      }\n    }));\n    this.registerAction(new react_canvas_core_1.Action({\n      type: react_canvas_core_1.InputType.MOUSE_UP,\n      fire: event => {\n        const model = this.engine.getMouseElement(event.event); // check to see if we connected to a new port\n\n        if (model instanceof PortModel_1.PortModel) {\n          if (this.port.canLinkToPort(model)) {\n            this.link.setTargetPort(model);\n            model.reportPosition();\n            this.engine.repaintCanvas();\n            return;\n          } else {\n            this.link.remove();\n            this.engine.repaintCanvas();\n            return;\n          }\n        }\n\n        if (!this.config.allowLooseLinks) {\n          this.link.remove();\n          this.engine.repaintCanvas();\n        }\n      }\n    }));\n  }\n  /**\n   * Calculates the link's far-end point position on mouse move.\n   * In order to be as precise as possible the mouse initialXRelative & initialYRelative are taken into account as well\n   * as the possible engine offset\n   */\n\n\n  fireMouseMoved(event) {\n    const portPos = this.port.getPosition();\n    const zoomLevelPercentage = this.engine.getModel().getZoomLevel() / 100;\n    const engineOffsetX = this.engine.getModel().getOffsetX() / zoomLevelPercentage;\n    const engineOffsetY = this.engine.getModel().getOffsetY() / zoomLevelPercentage;\n    const initialXRelative = this.initialXRelative / zoomLevelPercentage;\n    const initialYRelative = this.initialYRelative / zoomLevelPercentage;\n    const linkNextX = portPos.x - engineOffsetX + (initialXRelative - portPos.x) + event.virtualDisplacementX;\n    const linkNextY = portPos.y - engineOffsetY + (initialYRelative - portPos.y) + event.virtualDisplacementY;\n    this.link.getLastPoint().setPosition(linkNextX, linkNextY);\n    this.engine.repaintCanvas();\n  }\n\n}\n\nexports.DragNewLinkState = DragNewLinkState;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAOA;;AAiBA,MAAaA,gBAAb,SAAsCC,6CAAtC,CAA8E;AAK7EC,gBAAiD;AAAA,QAArCC,OAAqC,uEAAF,EAAE;AAChD,UAAM;AAAEC,UAAI,EAAE;AAAR,KAAN;AAEA,SAAKC,MAAL,GAAWC;AACVC,qBAAe,EAAE,IADP;AAEVC,+BAAyB,EAAE;AAFjB,OAGPL,OAHO,CAAX;AAMA,SAAKM,cAAL,CACC,IAAIR,0BAAJ,CAAW;AACVS,UAAI,EAAET,8BAAUU,UADN;AAEVC,UAAI,EAAGC,KAAD,IAA8C;AACnD,aAAKC,IAAL,GAAY,KAAKC,MAAL,CAAYC,eAAZ,CAA4BH,KAAK,CAACA,KAAlC,CAAZ;;AACA,YAAI,CAAC,KAAKR,MAAL,CAAYG,yBAAb,IAA0C,KAAKM,IAAL,CAAUG,QAAV,EAA9C,EAAoE;AACnE,eAAKC,KAAL;AACA;AACA;;AACD,aAAKC,IAAL,GAAY,KAAKL,IAAL,CAAUM,eAAV,EAAZ,CANmD,CAQnD;;AACA,YAAI,CAAC,KAAKD,IAAV,EAAgB;AACf,eAAKD,KAAL;AACA;AACA;;AACD,aAAKC,IAAL,CAAUE,WAAV,CAAsB,IAAtB;AACA,aAAKF,IAAL,CAAUG,aAAV,CAAwB,KAAKR,IAA7B;AACA,aAAKC,MAAL,CAAYQ,QAAZ,GAAuBC,OAAvB,CAA+B,KAAKL,IAApC;AACA,aAAKL,IAAL,CAAUW,cAAV;AACA;AAnBS,KAAX,CADD;AAwBA,SAAKhB,cAAL,CACC,IAAIR,0BAAJ,CAAW;AACVS,UAAI,EAAET,8BAAUyB,QADN;AAEVd,UAAI,EAAGC,KAAD,IAAmC;AACxC,cAAMc,KAAK,GAAG,KAAKZ,MAAL,CAAYC,eAAZ,CAA4BH,KAAK,CAACA,KAAlC,CAAd,CADwC,CAExC;;AACA,YAAIc,KAAK,YAAYC,qBAArB,EAAgC;AAC/B,cAAI,KAAKd,IAAL,CAAUe,aAAV,CAAwBF,KAAxB,CAAJ,EAAoC;AACnC,iBAAKR,IAAL,CAAUW,aAAV,CAAwBH,KAAxB;AACAA,iBAAK,CAACF,cAAN;AACA,iBAAKV,MAAL,CAAYgB,aAAZ;AACA;AACA,WALD,MAKO;AACN,iBAAKZ,IAAL,CAAUa,MAAV;AACA,iBAAKjB,MAAL,CAAYgB,aAAZ;AACA;AACA;AACD;;AAED,YAAI,CAAC,KAAK1B,MAAL,CAAYE,eAAjB,EAAkC;AACjC,eAAKY,IAAL,CAAUa,MAAV;AACA,eAAKjB,MAAL,CAAYgB,aAAZ;AACA;AACD;AAtBS,KAAX,CADD;AA0BA;AAED;;;;;;;AAKAE,gBAAc,CAACpB,KAAD,EAAsC;AACnD,UAAMqB,OAAO,GAAG,KAAKpB,IAAL,CAAUqB,WAAV,EAAhB;AACA,UAAMC,mBAAmB,GAAG,KAAKrB,MAAL,CAAYQ,QAAZ,GAAuBc,YAAvB,KAAwC,GAApE;AACA,UAAMC,aAAa,GAAG,KAAKvB,MAAL,CAAYQ,QAAZ,GAAuBgB,UAAvB,KAAsCH,mBAA5D;AACA,UAAMI,aAAa,GAAG,KAAKzB,MAAL,CAAYQ,QAAZ,GAAuBkB,UAAvB,KAAsCL,mBAA5D;AACA,UAAMM,gBAAgB,GAAG,KAAKA,gBAAL,GAAwBN,mBAAjD;AACA,UAAMO,gBAAgB,GAAG,KAAKA,gBAAL,GAAwBP,mBAAjD;AACA,UAAMQ,SAAS,GAAGV,OAAO,CAACW,CAAR,GAAYP,aAAZ,IAA6BI,gBAAgB,GAAGR,OAAO,CAACW,CAAxD,IAA6DhC,KAAK,CAACiC,oBAArF;AACA,UAAMC,SAAS,GAAGb,OAAO,CAACc,CAAR,GAAYR,aAAZ,IAA6BG,gBAAgB,GAAGT,OAAO,CAACc,CAAxD,IAA6DnC,KAAK,CAACoC,oBAArF;AAEA,SAAK9B,IAAL,CAAU+B,YAAV,GAAyBC,WAAzB,CAAqCP,SAArC,EAAgDG,SAAhD;AACA,SAAKhC,MAAL,CAAYgB,aAAZ;AACA;;AAnF4E;;AAA9EqB","names":["DragNewLinkState","react_canvas_core_1","constructor","options","name","config","Object","allowLooseLinks","allowLinksFromLockedPorts","registerAction","type","MOUSE_DOWN","fire","event","port","engine","getMouseElement","isLocked","eject","link","createLinkModel","setSelected","setSourcePort","getModel","addLink","reportPosition","MOUSE_UP","model","PortModel_1","canLinkToPort","setTargetPort","repaintCanvas","remove","fireMouseMoved","portPos","getPosition","zoomLevelPercentage","getZoomLevel","engineOffsetX","getOffsetX","engineOffsetY","getOffsetY","initialXRelative","initialYRelative","linkNextX","x","virtualDisplacementX","linkNextY","y","virtualDisplacementY","getLastPoint","setPosition","exports"],"sources":["C:\\Users\\nairr\\app-ui\\app-ui\\node_modules\\@projectstorm\\react-diagrams-core\\src\\states\\DragNewLinkState.ts"],"sourcesContent":["import {\n\tAbstractDisplacementState,\n\tAbstractDisplacementStateEvent,\n\tAction,\n\tActionEvent,\n\tInputType\n} from '@projectstorm/react-canvas-core';\nimport { PortModel } from '../entities/port/PortModel';\nimport { MouseEvent } from 'react';\nimport { LinkModel } from '../entities/link/LinkModel';\nimport { DiagramEngine } from '../DiagramEngine';\n\nexport interface DragNewLinkStateOptions {\n\t/**\n\t * If enabled, the links will stay on the canvas if they dont connect to a port\n\t * when dragging finishes\n\t */\n\tallowLooseLinks?: boolean;\n\t/**\n\t * If enabled, then a link can still be drawn from the port even if it is locked\n\t */\n\tallowLinksFromLockedPorts?: boolean;\n}\n\nexport class DragNewLinkState extends AbstractDisplacementState<DiagramEngine> {\n\tport: PortModel;\n\tlink: LinkModel;\n\tconfig: DragNewLinkStateOptions;\n\n\tconstructor(options: DragNewLinkStateOptions = {}) {\n\t\tsuper({ name: 'drag-new-link' });\n\n\t\tthis.config = {\n\t\t\tallowLooseLinks: true,\n\t\t\tallowLinksFromLockedPorts: false,\n\t\t\t...options\n\t\t};\n\n\t\tthis.registerAction(\n\t\t\tnew Action({\n\t\t\t\ttype: InputType.MOUSE_DOWN,\n\t\t\t\tfire: (event: ActionEvent<MouseEvent, PortModel>) => {\n\t\t\t\t\tthis.port = this.engine.getMouseElement(event.event) as PortModel;\n\t\t\t\t\tif (!this.config.allowLinksFromLockedPorts && this.port.isLocked()) {\n\t\t\t\t\t\tthis.eject();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.link = this.port.createLinkModel();\n\n\t\t\t\t\t// if no link is given, just eject the state\n\t\t\t\t\tif (!this.link) {\n\t\t\t\t\t\tthis.eject();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.link.setSelected(true);\n\t\t\t\t\tthis.link.setSourcePort(this.port);\n\t\t\t\t\tthis.engine.getModel().addLink(this.link);\n\t\t\t\t\tthis.port.reportPosition();\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\tthis.registerAction(\n\t\t\tnew Action({\n\t\t\t\ttype: InputType.MOUSE_UP,\n\t\t\t\tfire: (event: ActionEvent<MouseEvent>) => {\n\t\t\t\t\tconst model = this.engine.getMouseElement(event.event);\n\t\t\t\t\t// check to see if we connected to a new port\n\t\t\t\t\tif (model instanceof PortModel) {\n\t\t\t\t\t\tif (this.port.canLinkToPort(model)) {\n\t\t\t\t\t\t\tthis.link.setTargetPort(model);\n\t\t\t\t\t\t\tmodel.reportPosition();\n\t\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.link.remove();\n\t\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this.config.allowLooseLinks) {\n\t\t\t\t\t\tthis.link.remove();\n\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Calculates the link's far-end point position on mouse move.\n\t * In order to be as precise as possible the mouse initialXRelative & initialYRelative are taken into account as well\n\t * as the possible engine offset\n\t */\n\tfireMouseMoved(event: AbstractDisplacementStateEvent): any {\n\t\tconst portPos = this.port.getPosition();\n\t\tconst zoomLevelPercentage = this.engine.getModel().getZoomLevel() / 100;\n\t\tconst engineOffsetX = this.engine.getModel().getOffsetX() / zoomLevelPercentage;\n\t\tconst engineOffsetY = this.engine.getModel().getOffsetY() / zoomLevelPercentage;\n\t\tconst initialXRelative = this.initialXRelative / zoomLevelPercentage;\n\t\tconst initialYRelative = this.initialYRelative / zoomLevelPercentage;\n\t\tconst linkNextX = portPos.x - engineOffsetX + (initialXRelative - portPos.x) + event.virtualDisplacementX;\n\t\tconst linkNextY = portPos.y - engineOffsetY + (initialYRelative - portPos.y) + event.virtualDisplacementY;\n\n\t\tthis.link.getLastPoint().setPosition(linkNextX, linkNextY);\n\t\tthis.engine.repaintCanvas();\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RightAngleLinkWidget = void 0;\n\nconst React = require(\"react\");\n\nconst react_diagrams_core_1 = require(\"@projectstorm/react-diagrams-core\");\n\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\n\nconst geometry_1 = require(\"@projectstorm/geometry\");\n\nclass RightAngleLinkWidget extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.handleMove = function (event) {\n      this.draggingEvent(event, this.dragging_index);\n    }.bind(this);\n\n    this.handleUp = function (event) {\n      // Unregister handlers to avoid multiple event handlers for other links\n      this.setState({\n        canDrag: false,\n        selected: false\n      });\n      window.removeEventListener('mousemove', this.handleMove);\n      window.removeEventListener('mouseup', this.handleUp);\n    }.bind(this);\n\n    this.refPaths = [];\n    this.state = {\n      selected: false,\n      canDrag: false\n    };\n    this.dragging_index = 0;\n  }\n\n  componentDidUpdate() {\n    this.props.link.setRenderedPaths(this.refPaths.map(ref => {\n      return ref.current;\n    }));\n  }\n\n  componentDidMount() {\n    this.props.link.setRenderedPaths(this.refPaths.map(ref => {\n      return ref.current;\n    }));\n  }\n\n  componentWillUnmount() {\n    this.props.link.setRenderedPaths([]);\n  }\n\n  generateLink(path, extraProps, id) {\n    const ref = React.createRef();\n    this.refPaths.push(ref);\n    return React.createElement(react_diagrams_defaults_1.DefaultLinkSegmentWidget, {\n      key: `link-${id}`,\n      path: path,\n      selected: this.state.selected,\n      diagramEngine: this.props.diagramEngine,\n      factory: this.props.diagramEngine.getFactoryForLink(this.props.link),\n      link: this.props.link,\n      forwardRef: ref,\n      onSelection: selected => {\n        this.setState({\n          selected: selected\n        });\n      },\n      extras: extraProps\n    });\n  }\n\n  calculatePositions(points, event, index, coordinate) {\n    // If path is first or last add another point to keep node port on its position\n    if (index === 0) {\n      let point = new react_diagrams_core_1.PointModel({\n        link: this.props.link,\n        position: new geometry_1.Point(points[index].getX(), points[index].getY())\n      });\n      this.props.link.addPoint(point, index);\n      this.dragging_index++;\n      return;\n    } else if (index === points.length - 2) {\n      let point = new react_diagrams_core_1.PointModel({\n        link: this.props.link,\n        position: new geometry_1.Point(points[index + 1].getX(), points[index + 1].getY())\n      });\n      this.props.link.addPoint(point, index + 1);\n      return;\n    } // Merge two points if it is not close to node port and close to each other\n\n\n    if (index - 2 > 0) {\n      let _points = {\n        [index - 2]: points[index - 2].getPosition(),\n        [index + 1]: points[index + 1].getPosition(),\n        [index - 1]: points[index - 1].getPosition()\n      };\n\n      if (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\n        _points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        points[index - 2].setPosition(_points[index - 2]);\n        points[index + 1].setPosition(_points[index + 1]);\n        points[index - 1].remove();\n        points[index - 1].remove();\n        this.dragging_index--;\n        this.dragging_index--;\n        return;\n      }\n    } // Merge two points if it is not close to node port\n\n\n    if (index + 2 < points.length - 2) {\n      let _points = {\n        [index + 3]: points[index + 3].getPosition(),\n        [index + 2]: points[index + 2].getPosition(),\n        [index + 1]: points[index + 1].getPosition(),\n        [index]: points[index].getPosition()\n      };\n\n      if (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\n        _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        _points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        points[index].setPosition(_points[index]);\n        points[index + 3].setPosition(_points[index + 3]);\n        points[index + 1].remove();\n        points[index + 1].remove();\n        return;\n      }\n    } // If no condition above handled then just update path points position\n\n\n    let _points = {\n      [index]: points[index].getPosition(),\n      [index + 1]: points[index + 1].getPosition()\n    };\n    _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n    _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n    points[index].setPosition(_points[index]);\n    points[index + 1].setPosition(_points[index + 1]);\n  }\n\n  draggingEvent(event, index) {\n    let points = this.props.link.getPoints(); // get moving difference. Index + 1 will work because links indexes has\n    // length = points.lenght - 1\n\n    let dx = Math.abs(points[index].getX() - points[index + 1].getX());\n    let dy = Math.abs(points[index].getY() - points[index + 1].getY()); // moving with y direction\n\n    if (dx === 0) {\n      this.calculatePositions(points, event, index, 'x');\n    } else if (dy === 0) {\n      this.calculatePositions(points, event, index, 'y');\n    }\n\n    this.props.link.setFirstAndLastPathsDirection();\n  }\n\n  render() {\n    //ensure id is present for all points on the path\n    let points = this.props.link.getPoints();\n    let paths = []; // Get points based on link orientation\n\n    let pointLeft = points[0];\n    let pointRight = points[points.length - 1];\n    let hadToSwitch = false;\n\n    if (pointLeft.getX() > pointRight.getX()) {\n      pointLeft = points[points.length - 1];\n      pointRight = points[0];\n      hadToSwitch = true;\n    }\n\n    let dy = Math.abs(points[0].getY() - points[points.length - 1].getY()); // When new link add one middle point to get everywhere 90° angle\n\n    if (this.props.link.getTargetPort() === null && points.length === 2) {\n      [...Array(2)].forEach(item => {\n        this.props.link.addPoint(new react_diagrams_core_1.PointModel({\n          link: this.props.link,\n          position: new geometry_1.Point(pointLeft.getX(), pointRight.getY())\n        }), 1);\n      });\n      this.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n    } // When new link is moving and not connected to target port move with middle point\n    // TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n    //  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n    else if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n      points[1].setPosition(pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2, !hadToSwitch ? pointLeft.getY() : pointRight.getY());\n      points[2].setPosition(pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2, !hadToSwitch ? pointRight.getY() : pointLeft.getY());\n    } // Render was called but link is not moved but user.\n    // Node is moved and in this case fix coordinates to get 90° angle.\n    // For loop just for first and last path\n    else if (!this.state.canDrag && points.length > 2) {\n      // Those points and its position only will be moved\n      for (let i = 1; i < points.length; i += points.length - 2) {\n        if (i - 1 === 0) {\n          if (this.props.link.getFirstPathXdirection()) {\n            points[i].setPosition(points[i].getX(), points[i - 1].getY());\n          } else {\n            points[i].setPosition(points[i - 1].getX(), points[i].getY());\n          }\n        } else {\n          if (this.props.link.getLastPathXdirection()) {\n            points[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n          } else {\n            points[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n          }\n        }\n      }\n    } // If there is existing link which has two points add one\n    // NOTE: It doesn't matter if check is for dy or dx\n\n\n    if (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n      this.props.link.addPoint(new react_diagrams_core_1.PointModel({\n        link: this.props.link,\n        position: new geometry_1.Point(pointLeft.getX(), pointRight.getY())\n      }));\n    }\n\n    for (let j = 0; j < points.length - 1; j++) {\n      paths.push(this.generateLink(react_diagrams_core_1.LinkWidget.generateLinePath(points[j], points[j + 1]), {\n        'data-linkid': this.props.link.getID(),\n        'data-point': j,\n        onMouseDown: event => {\n          if (event.button === 0) {\n            this.setState({\n              canDrag: true\n            });\n            this.dragging_index = j; // Register mouse move event to track mouse position\n            // On mouse up these events are unregistered check \"this.handleUp\"\n\n            window.addEventListener('mousemove', this.handleMove);\n            window.addEventListener('mouseup', this.handleUp);\n          }\n        },\n        onMouseEnter: event => {\n          this.setState({\n            selected: true\n          });\n          this.props.link.lastHoverIndexOfPath = j;\n        }\n      }, j));\n    }\n\n    this.refPaths = [];\n    return React.createElement(\"g\", {\n      \"data-default-link-test\": this.props.link.getOptions().testName\n    }, paths);\n  }\n\n}\n\nexports.RightAngleLinkWidget = RightAngleLinkWidget;\nRightAngleLinkWidget.defaultProps = {\n  color: 'red',\n  width: 3,\n  link: null,\n  smooth: false,\n  diagramEngine: null,\n  factory: null\n};","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AAEA;;AACA;;AAkBA,MAAaA,oBAAb,SAA0CC,KAAK,CAACC,SAAhD,CAAmG;AAgBlGC,cAAYC,KAAZ,EAAsC;AACrC,UAAMA,KAAN;;AAwID,sBAAa,UAAUC,KAAV,EAA2B;AACvC,WAAKC,aAAL,CAAmBD,KAAnB,EAA0B,KAAKE,cAA/B;AACA,KAFY,CAEXC,IAFW,CAEN,IAFM,CAAb;;AAIA,oBAAW,UAAUH,KAAV,EAA2B;AACrC;AACA,WAAKI,QAAL,CAAc;AAAEC,eAAO,EAAE,KAAX;AAAkBC,gBAAQ,EAAE;AAA5B,OAAd;AACAC,YAAM,CAACC,mBAAP,CAA2B,WAA3B,EAAwC,KAAKC,UAA7C;AACAF,YAAM,CAACC,mBAAP,CAA2B,SAA3B,EAAsC,KAAKE,QAA3C;AACA,KALU,CAKTP,IALS,CAKJ,IALI,CAAX;;AA1IC,SAAKQ,QAAL,GAAgB,EAAhB;AACA,SAAKC,KAAL,GAAa;AACZN,cAAQ,EAAE,KADE;AAEZD,aAAO,EAAE;AAFG,KAAb;AAKA,SAAKH,cAAL,GAAsB,CAAtB;AACA;;AAEDW,oBAAkB;AACjB,SAAKd,KAAL,CAAWe,IAAX,CAAgBC,gBAAhB,CACC,KAAKJ,QAAL,CAAcK,GAAd,CAAmBC,GAAD,IAAQ;AACzB,aAAOA,GAAG,CAACC,OAAX;AACA,KAFD,CADD;AAKA;;AAEDC,mBAAiB;AAChB,SAAKpB,KAAL,CAAWe,IAAX,CAAgBC,gBAAhB,CACC,KAAKJ,QAAL,CAAcK,GAAd,CAAmBC,GAAD,IAAQ;AACzB,aAAOA,GAAG,CAACC,OAAX;AACA,KAFD,CADD;AAKA;;AAEDE,sBAAoB;AACnB,SAAKrB,KAAL,CAAWe,IAAX,CAAgBC,gBAAhB,CAAiC,EAAjC;AACA;;AAEDM,cAAY,CAACC,IAAD,EAAeC,UAAf,EAAgCC,EAAhC,EAAmD;AAC9D,UAAMP,GAAG,GAAGrB,KAAK,CAAC6B,SAAN,EAAZ;AACA,SAAKd,QAAL,CAAce,IAAd,CAAmBT,GAAnB;AACA,WACCrB,oBAAC+B,kDAAD,EAAyB;AACxBC,SAAG,EAAE,QAAQJ,EAAE,EADS;AAExBF,UAAI,EAAEA,IAFkB;AAGxBhB,cAAQ,EAAE,KAAKM,KAAL,CAAWN,QAHG;AAIxBuB,mBAAa,EAAE,KAAK9B,KAAL,CAAW8B,aAJF;AAKxBC,aAAO,EAAE,KAAK/B,KAAL,CAAW8B,aAAX,CAAyBE,iBAAzB,CAA2C,KAAKhC,KAAL,CAAWe,IAAtD,CALe;AAMxBA,UAAI,EAAE,KAAKf,KAAL,CAAWe,IANO;AAOxBkB,gBAAU,EAAEf,GAPY;AAQxBgB,iBAAW,EAAG3B,QAAD,IAAa;AACzB,aAAKF,QAAL,CAAc;AAAEE,kBAAQ,EAAEA;AAAZ,SAAd;AACA,OAVuB;AAWxB4B,YAAM,EAAEX;AAXgB,KAAzB,CADD;AAeA;;AAEDY,oBAAkB,CAACC,MAAD,EAAuBpC,KAAvB,EAA0CqC,KAA1C,EAAyDC,UAAzD,EAA2E;AAC5F;AACA,QAAID,KAAK,KAAK,CAAd,EAAiB;AAChB,UAAIE,KAAK,GAAG,IAAIC,gCAAJ,CAAe;AAC1B1B,YAAI,EAAE,KAAKf,KAAL,CAAWe,IADS;AAE1B2B,gBAAQ,EAAE,IAAIC,gBAAJ,CAAUN,MAAM,CAACC,KAAD,CAAN,CAAcM,IAAd,EAAV,EAAgCP,MAAM,CAACC,KAAD,CAAN,CAAcO,IAAd,EAAhC;AAFgB,OAAf,CAAZ;AAIA,WAAK7C,KAAL,CAAWe,IAAX,CAAgB+B,QAAhB,CAAyBN,KAAzB,EAAgCF,KAAhC;AACA,WAAKnC,cAAL;AACA;AACA,KARD,MAQO,IAAImC,KAAK,KAAKD,MAAM,CAACU,MAAP,GAAgB,CAA9B,EAAiC;AACvC,UAAIP,KAAK,GAAG,IAAIC,gCAAJ,CAAe;AAC1B1B,YAAI,EAAE,KAAKf,KAAL,CAAWe,IADS;AAE1B2B,gBAAQ,EAAE,IAAIC,gBAAJ,CAAUN,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBM,IAAlB,EAAV,EAAoCP,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBO,IAAlB,EAApC;AAFgB,OAAf,CAAZ;AAIA,WAAK7C,KAAL,CAAWe,IAAX,CAAgB+B,QAAhB,CAAyBN,KAAzB,EAAgCF,KAAK,GAAG,CAAxC;AACA;AACA,KAjB2F,CAmB5F;;;AACA,QAAIA,KAAK,GAAG,CAAR,GAAY,CAAhB,EAAmB;AAClB,UAAIU,OAAO,GAAG;AACb,SAACV,KAAK,GAAG,CAAT,GAAaD,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBW,WAAlB,EADA;AAEb,SAACX,KAAK,GAAG,CAAT,GAAaD,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBW,WAAlB,EAFA;AAGb,SAACX,KAAK,GAAG,CAAT,GAAaD,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBW,WAAlB;AAHA,OAAd;;AAKA,UAAIC,IAAI,CAACC,GAAL,CAASH,OAAO,CAACV,KAAK,GAAG,CAAT,CAAP,CAAmBC,UAAnB,IAAiCS,OAAO,CAACV,KAAK,GAAG,CAAT,CAAP,CAAmBC,UAAnB,CAA1C,IAA4E,CAAhF,EAAmF;AAClFS,eAAO,CAACV,KAAK,GAAG,CAAT,CAAP,CAAmBC,UAAnB,IAAiC,KAAKvC,KAAL,CAAW8B,aAAX,CAAyBsB,qBAAzB,CAA+CnD,KAA/C,EAAsDsC,UAAtD,CAAjC;AACAS,eAAO,CAACV,KAAK,GAAG,CAAT,CAAP,CAAmBC,UAAnB,IAAiC,KAAKvC,KAAL,CAAW8B,aAAX,CAAyBsB,qBAAzB,CAA+CnD,KAA/C,EAAsDsC,UAAtD,CAAjC;AACAF,cAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBe,WAAlB,CAA8BL,OAAO,CAACV,KAAK,GAAG,CAAT,CAArC;AACAD,cAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBe,WAAlB,CAA8BL,OAAO,CAACV,KAAK,GAAG,CAAT,CAArC;AACAD,cAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBgB,MAAlB;AACAjB,cAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBgB,MAAlB;AACA,aAAKnD,cAAL;AACA,aAAKA,cAAL;AACA;AACA;AACD,KArC2F,CAuC5F;;;AACA,QAAImC,KAAK,GAAG,CAAR,GAAYD,MAAM,CAACU,MAAP,GAAgB,CAAhC,EAAmC;AAClC,UAAIC,OAAO,GAAG;AACb,SAACV,KAAK,GAAG,CAAT,GAAaD,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBW,WAAlB,EADA;AAEb,SAACX,KAAK,GAAG,CAAT,GAAaD,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBW,WAAlB,EAFA;AAGb,SAACX,KAAK,GAAG,CAAT,GAAaD,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBW,WAAlB,EAHA;AAIb,SAACX,KAAD,GAASD,MAAM,CAACC,KAAD,CAAN,CAAcW,WAAd;AAJI,OAAd;;AAMA,UAAIC,IAAI,CAACC,GAAL,CAASH,OAAO,CAACV,KAAK,GAAG,CAAT,CAAP,CAAmBC,UAAnB,IAAiCS,OAAO,CAACV,KAAK,GAAG,CAAT,CAAP,CAAmBC,UAAnB,CAA1C,IAA4E,CAAhF,EAAmF;AAClFS,eAAO,CAACV,KAAD,CAAP,CAAeC,UAAf,IAA6B,KAAKvC,KAAL,CAAW8B,aAAX,CAAyBsB,qBAAzB,CAA+CnD,KAA/C,EAAsDsC,UAAtD,CAA7B;AACAS,eAAO,CAACV,KAAK,GAAG,CAAT,CAAP,CAAmBC,UAAnB,IAAiC,KAAKvC,KAAL,CAAW8B,aAAX,CAAyBsB,qBAAzB,CAA+CnD,KAA/C,EAAsDsC,UAAtD,CAAjC;AACAF,cAAM,CAACC,KAAD,CAAN,CAAce,WAAd,CAA0BL,OAAO,CAACV,KAAD,CAAjC;AACAD,cAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBe,WAAlB,CAA8BL,OAAO,CAACV,KAAK,GAAG,CAAT,CAArC;AACAD,cAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBgB,MAAlB;AACAjB,cAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBgB,MAAlB;AACA;AACA;AACD,KAxD2F,CA0D5F;;;AACA,QAAIN,OAAO,GAAG;AACb,OAACV,KAAD,GAASD,MAAM,CAACC,KAAD,CAAN,CAAcW,WAAd,EADI;AAEb,OAACX,KAAK,GAAG,CAAT,GAAaD,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBW,WAAlB;AAFA,KAAd;AAIAD,WAAO,CAACV,KAAD,CAAP,CAAeC,UAAf,IAA6B,KAAKvC,KAAL,CAAW8B,aAAX,CAAyBsB,qBAAzB,CAA+CnD,KAA/C,EAAsDsC,UAAtD,CAA7B;AACAS,WAAO,CAACV,KAAK,GAAG,CAAT,CAAP,CAAmBC,UAAnB,IAAiC,KAAKvC,KAAL,CAAW8B,aAAX,CAAyBsB,qBAAzB,CAA+CnD,KAA/C,EAAsDsC,UAAtD,CAAjC;AACAF,UAAM,CAACC,KAAD,CAAN,CAAce,WAAd,CAA0BL,OAAO,CAACV,KAAD,CAAjC;AACAD,UAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBe,WAAlB,CAA8BL,OAAO,CAACV,KAAK,GAAG,CAAT,CAArC;AACA;;AAEDpC,eAAa,CAACD,KAAD,EAAoBqC,KAApB,EAAiC;AAC7C,QAAID,MAAM,GAAG,KAAKrC,KAAL,CAAWe,IAAX,CAAgBwC,SAAhB,EAAb,CAD6C,CAE7C;AACA;;AACA,QAAIC,EAAE,GAAGN,IAAI,CAACC,GAAL,CAASd,MAAM,CAACC,KAAD,CAAN,CAAcM,IAAd,KAAuBP,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBM,IAAlB,EAAhC,CAAT;AACA,QAAIa,EAAE,GAAGP,IAAI,CAACC,GAAL,CAASd,MAAM,CAACC,KAAD,CAAN,CAAcO,IAAd,KAAuBR,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,CAAkBO,IAAlB,EAAhC,CAAT,CAL6C,CAO7C;;AACA,QAAIW,EAAE,KAAK,CAAX,EAAc;AACb,WAAKpB,kBAAL,CAAwBC,MAAxB,EAAgCpC,KAAhC,EAAuCqC,KAAvC,EAA8C,GAA9C;AACA,KAFD,MAEO,IAAImB,EAAE,KAAK,CAAX,EAAc;AACpB,WAAKrB,kBAAL,CAAwBC,MAAxB,EAAgCpC,KAAhC,EAAuCqC,KAAvC,EAA8C,GAA9C;AACA;;AACD,SAAKtC,KAAL,CAAWe,IAAX,CAAgB2C,6BAAhB;AACA;;AAaDC,QAAM;AACL;AACA,QAAItB,MAAM,GAAG,KAAKrC,KAAL,CAAWe,IAAX,CAAgBwC,SAAhB,EAAb;AACA,QAAIK,KAAK,GAAG,EAAZ,CAHK,CAKL;;AACA,QAAIC,SAAS,GAAGxB,MAAM,CAAC,CAAD,CAAtB;AACA,QAAIyB,UAAU,GAAGzB,MAAM,CAACA,MAAM,CAACU,MAAP,GAAgB,CAAjB,CAAvB;AACA,QAAIgB,WAAW,GAAG,KAAlB;;AACA,QAAIF,SAAS,CAACjB,IAAV,KAAmBkB,UAAU,CAAClB,IAAX,EAAvB,EAA0C;AACzCiB,eAAS,GAAGxB,MAAM,CAACA,MAAM,CAACU,MAAP,GAAgB,CAAjB,CAAlB;AACAe,gBAAU,GAAGzB,MAAM,CAAC,CAAD,CAAnB;AACA0B,iBAAW,GAAG,IAAd;AACA;;AACD,QAAIN,EAAE,GAAGP,IAAI,CAACC,GAAL,CAASd,MAAM,CAAC,CAAD,CAAN,CAAUQ,IAAV,KAAmBR,MAAM,CAACA,MAAM,CAACU,MAAP,GAAgB,CAAjB,CAAN,CAA0BF,IAA1B,EAA5B,CAAT,CAdK,CAgBL;;AACA,QAAI,KAAK7C,KAAL,CAAWe,IAAX,CAAgBiD,aAAhB,OAAoC,IAApC,IAA4C3B,MAAM,CAACU,MAAP,KAAkB,CAAlE,EAAqE;AACpE,OAAC,GAAGkB,KAAK,CAAC,CAAD,CAAT,EAAcC,OAAd,CAAuBC,IAAD,IAAS;AAC9B,aAAKnE,KAAL,CAAWe,IAAX,CAAgB+B,QAAhB,CACC,IAAIL,gCAAJ,CAAe;AACd1B,cAAI,EAAE,KAAKf,KAAL,CAAWe,IADH;AAEd2B,kBAAQ,EAAE,IAAIC,gBAAJ,CAAUkB,SAAS,CAACjB,IAAV,EAAV,EAA4BkB,UAAU,CAACjB,IAAX,EAA5B;AAFI,SAAf,CADD,EAKC,CALD;AAOA,OARD;AASA,WAAK7C,KAAL,CAAWe,IAAX,CAAgBqD,qCAAhB,CAAsD,IAAtD,EAA4D,IAA5D;AACA,KAXD,CAYA;AACA;AACA;AAdA,SAeK,IAAI,KAAKpE,KAAL,CAAWe,IAAX,CAAgBiD,aAAhB,OAAoC,IAApC,IAA4C,KAAKhE,KAAL,CAAWe,IAAX,CAAgBsD,aAAhB,OAAoC,IAApF,EAA0F;AAC9FhC,YAAM,CAAC,CAAD,CAAN,CAAUgB,WAAV,CACCS,UAAU,CAAClB,IAAX,KAAoB,CAACiB,SAAS,CAACjB,IAAV,KAAmBkB,UAAU,CAAClB,IAAX,EAApB,IAAyC,CAD9D,EAEC,CAACmB,WAAD,GAAeF,SAAS,CAAChB,IAAV,EAAf,GAAkCiB,UAAU,CAACjB,IAAX,EAFnC;AAIAR,YAAM,CAAC,CAAD,CAAN,CAAUgB,WAAV,CACCS,UAAU,CAAClB,IAAX,KAAoB,CAACiB,SAAS,CAACjB,IAAV,KAAmBkB,UAAU,CAAClB,IAAX,EAApB,IAAyC,CAD9D,EAEC,CAACmB,WAAD,GAAeD,UAAU,CAACjB,IAAX,EAAf,GAAmCgB,SAAS,CAAChB,IAAV,EAFpC;AAIA,KATI,CAUL;AACA;AACA;AAZK,SAaA,IAAI,CAAC,KAAKhC,KAAL,CAAWP,OAAZ,IAAuB+B,MAAM,CAACU,MAAP,GAAgB,CAA3C,EAA8C;AAClD;AACA,WAAK,IAAIuB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,MAAM,CAACU,MAA3B,EAAmCuB,CAAC,IAAIjC,MAAM,CAACU,MAAP,GAAgB,CAAxD,EAA2D;AAC1D,YAAIuB,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiB;AAChB,cAAI,KAAKtE,KAAL,CAAWe,IAAX,CAAgBwD,sBAAhB,EAAJ,EAA8C;AAC7ClC,kBAAM,CAACiC,CAAD,CAAN,CAAUjB,WAAV,CAAsBhB,MAAM,CAACiC,CAAD,CAAN,CAAU1B,IAAV,EAAtB,EAAwCP,MAAM,CAACiC,CAAC,GAAG,CAAL,CAAN,CAAczB,IAAd,EAAxC;AACA,WAFD,MAEO;AACNR,kBAAM,CAACiC,CAAD,CAAN,CAAUjB,WAAV,CAAsBhB,MAAM,CAACiC,CAAC,GAAG,CAAL,CAAN,CAAc1B,IAAd,EAAtB,EAA4CP,MAAM,CAACiC,CAAD,CAAN,CAAUzB,IAAV,EAA5C;AACA;AACD,SAND,MAMO;AACN,cAAI,KAAK7C,KAAL,CAAWe,IAAX,CAAgByD,qBAAhB,EAAJ,EAA6C;AAC5CnC,kBAAM,CAACiC,CAAC,GAAG,CAAL,CAAN,CAAcjB,WAAd,CAA0BhB,MAAM,CAACiC,CAAC,GAAG,CAAL,CAAN,CAAc1B,IAAd,EAA1B,EAAgDP,MAAM,CAACiC,CAAD,CAAN,CAAUzB,IAAV,EAAhD;AACA,WAFD,MAEO;AACNR,kBAAM,CAACiC,CAAC,GAAG,CAAL,CAAN,CAAcjB,WAAd,CAA0BhB,MAAM,CAACiC,CAAD,CAAN,CAAU1B,IAAV,EAA1B,EAA4CP,MAAM,CAACiC,CAAC,GAAG,CAAL,CAAN,CAAczB,IAAd,EAA5C;AACA;AACD;AACD;AACD,KA9DI,CAgEL;AACA;;;AACA,QAAIR,MAAM,CAACU,MAAP,KAAkB,CAAlB,IAAuBU,EAAE,KAAK,CAA9B,IAAmC,CAAC,KAAK5C,KAAL,CAAWP,OAAnD,EAA4D;AAC3D,WAAKN,KAAL,CAAWe,IAAX,CAAgB+B,QAAhB,CACC,IAAIL,gCAAJ,CAAe;AACd1B,YAAI,EAAE,KAAKf,KAAL,CAAWe,IADH;AAEd2B,gBAAQ,EAAE,IAAIC,gBAAJ,CAAUkB,SAAS,CAACjB,IAAV,EAAV,EAA4BkB,UAAU,CAACjB,IAAX,EAA5B;AAFI,OAAf,CADD;AAMA;;AAED,SAAK,IAAI4B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpC,MAAM,CAACU,MAAP,GAAgB,CAApC,EAAuC0B,CAAC,EAAxC,EAA4C;AAC3Cb,WAAK,CAACjC,IAAN,CACC,KAAKL,YAAL,CACCmB,iCAAWiC,gBAAX,CAA4BrC,MAAM,CAACoC,CAAD,CAAlC,EAAuCpC,MAAM,CAACoC,CAAC,GAAG,CAAL,CAA7C,CADD,EAEC;AACC,uBAAe,KAAKzE,KAAL,CAAWe,IAAX,CAAgB4D,KAAhB,EADhB;AAEC,sBAAcF,CAFf;AAGCG,mBAAW,EAAG3E,KAAD,IAAsB;AAClC,cAAIA,KAAK,CAAC4E,MAAN,KAAiB,CAArB,EAAwB;AACvB,iBAAKxE,QAAL,CAAc;AAAEC,qBAAO,EAAE;AAAX,aAAd;AACA,iBAAKH,cAAL,GAAsBsE,CAAtB,CAFuB,CAGvB;AACA;;AACAjE,kBAAM,CAACsE,gBAAP,CAAwB,WAAxB,EAAqC,KAAKpE,UAA1C;AACAF,kBAAM,CAACsE,gBAAP,CAAwB,SAAxB,EAAmC,KAAKnE,QAAxC;AACA;AACD,SAZF;AAaCoE,oBAAY,EAAG9E,KAAD,IAAsB;AACnC,eAAKI,QAAL,CAAc;AAAEE,oBAAQ,EAAE;AAAZ,WAAd;AACA,eAAKP,KAAL,CAAWe,IAAX,CAAgBiE,oBAAhB,GAAuCP,CAAvC;AACA;AAhBF,OAFD,EAoBCA,CApBD,CADD;AAwBA;;AAED,SAAK7D,QAAL,GAAgB,EAAhB;AACA,WAAOf;AAAA,gCAA2B,KAAKG,KAAL,CAAWe,IAAX,CAAgBkE,UAAhB,GAA6BC;AAAxD,OAAmEtB,KAAnE,CAAP;AACA;;AA5QiG;;AAAnGuB;AACevF,oCAAoC;AACjDwF,OAAK,EAAE,KAD0C;AAEjDC,OAAK,EAAE,CAF0C;AAGjDtE,MAAI,EAAE,IAH2C;AAIjDuE,QAAM,EAAE,KAJyC;AAKjDxD,eAAa,EAAE,IALkC;AAMjDC,SAAO,EAAE;AANwC,CAApC","names":["RightAngleLinkWidget","React","Component","constructor","props","event","draggingEvent","dragging_index","bind","setState","canDrag","selected","window","removeEventListener","handleMove","handleUp","refPaths","state","componentDidUpdate","link","setRenderedPaths","map","ref","current","componentDidMount","componentWillUnmount","generateLink","path","extraProps","id","createRef","push","react_diagrams_defaults_1","key","diagramEngine","factory","getFactoryForLink","forwardRef","onSelection","extras","calculatePositions","points","index","coordinate","point","react_diagrams_core_1","position","geometry_1","getX","getY","addPoint","length","_points","getPosition","Math","abs","getRelativeMousePoint","setPosition","remove","getPoints","dx","dy","setFirstAndLastPathsDirection","render","paths","pointLeft","pointRight","hadToSwitch","getTargetPort","Array","forEach","item","setManuallyFirstAndLastPathsDirection","getSourcePort","i","getFirstPathXdirection","getLastPathXdirection","j","generateLinePath","getID","onMouseDown","button","addEventListener","onMouseEnter","lastHoverIndexOfPath","getOptions","testName","exports","color","width","smooth"],"sources":["C:\\Users\\nairr\\app-ui\\app-ui\\node_modules\\@projectstorm\\react-diagrams-routing\\src\\link\\RightAngleLinkWidget.tsx"],"sourcesContent":["import * as React from 'react';\nimport { DiagramEngine, LinkWidget, PointModel } from '@projectstorm/react-diagrams-core';\nimport { RightAngleLinkFactory } from './RightAngleLinkFactory';\nimport { DefaultLinkModel, DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\nimport { Point } from '@projectstorm/geometry';\nimport { MouseEvent } from 'react';\nimport { RightAngleLinkModel } from './RightAngleLinkModel';\n\nexport interface RightAngleLinkProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: RightAngleLinkModel;\n\tdiagramEngine: DiagramEngine;\n\tfactory: RightAngleLinkFactory;\n}\n\nexport interface RightAngleLinkState {\n\tselected: boolean;\n\tcanDrag: boolean;\n}\n\nexport class RightAngleLinkWidget extends React.Component<RightAngleLinkProps, RightAngleLinkState> {\n\tpublic static defaultProps: RightAngleLinkProps = {\n\t\tcolor: 'red',\n\t\twidth: 3,\n\t\tlink: null,\n\t\tsmooth: false,\n\t\tdiagramEngine: null,\n\t\tfactory: null\n\t};\n\n\trefPaths: React.RefObject<SVGPathElement>[];\n\n\t// DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n\trefLabels: { [id: string]: HTMLElement };\n\tdragging_index: number;\n\n\tconstructor(props: RightAngleLinkProps) {\n\t\tsuper(props);\n\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false,\n\t\t\tcanDrag: false\n\t\t};\n\n\t\tthis.dragging_index = 0;\n\t}\n\n\tcomponentDidUpdate(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentDidMount(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.props.link.setRenderedPaths([]);\n\t}\n\n\tgenerateLink(path: string, extraProps: any, id: string | number): JSX.Element {\n\t\tconst ref = React.createRef<SVGPathElement>();\n\t\tthis.refPaths.push(ref);\n\t\treturn (\n\t\t\t<DefaultLinkSegmentWidget\n\t\t\t\tkey={`link-${id}`}\n\t\t\t\tpath={path}\n\t\t\t\tselected={this.state.selected}\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n\t\t\t\tlink={this.props.link}\n\t\t\t\tforwardRef={ref}\n\t\t\t\tonSelection={(selected) => {\n\t\t\t\t\tthis.setState({ selected: selected });\n\t\t\t\t}}\n\t\t\t\textras={extraProps}\n\t\t\t/>\n\t\t);\n\t}\n\n\tcalculatePositions(points: PointModel[], event: MouseEvent, index: number, coordinate: string) {\n\t\t// If path is first or last add another point to keep node port on its position\n\t\tif (index === 0) {\n\t\t\tlet point = new PointModel({\n\t\t\t\tlink: this.props.link,\n\t\t\t\tposition: new Point(points[index].getX(), points[index].getY())\n\t\t\t});\n\t\t\tthis.props.link.addPoint(point, index);\n\t\t\tthis.dragging_index++;\n\t\t\treturn;\n\t\t} else if (index === points.length - 2) {\n\t\t\tlet point = new PointModel({\n\t\t\t\tlink: this.props.link,\n\t\t\t\tposition: new Point(points[index + 1].getX(), points[index + 1].getY())\n\t\t\t});\n\t\t\tthis.props.link.addPoint(point, index + 1);\n\t\t\treturn;\n\t\t}\n\n\t\t// Merge two points if it is not close to node port and close to each other\n\t\tif (index - 2 > 0) {\n\t\t\tlet _points = {\n\t\t\t\t[index - 2]: points[index - 2].getPosition(),\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\n\t\t\t\t[index - 1]: points[index - 1].getPosition()\n\t\t\t};\n\t\t\tif (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\n\t\t\t\t_points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\tpoints[index - 2].setPosition(_points[index - 2]);\n\t\t\t\tpoints[index + 1].setPosition(_points[index + 1]);\n\t\t\t\tpoints[index - 1].remove();\n\t\t\t\tpoints[index - 1].remove();\n\t\t\t\tthis.dragging_index--;\n\t\t\t\tthis.dragging_index--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Merge two points if it is not close to node port\n\t\tif (index + 2 < points.length - 2) {\n\t\t\tlet _points = {\n\t\t\t\t[index + 3]: points[index + 3].getPosition(),\n\t\t\t\t[index + 2]: points[index + 2].getPosition(),\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\n\t\t\t\t[index]: points[index].getPosition()\n\t\t\t};\n\t\t\tif (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\n\t\t\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\t_points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\tpoints[index].setPosition(_points[index]);\n\t\t\t\tpoints[index + 3].setPosition(_points[index + 3]);\n\t\t\t\tpoints[index + 1].remove();\n\t\t\t\tpoints[index + 1].remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If no condition above handled then just update path points position\n\t\tlet _points = {\n\t\t\t[index]: points[index].getPosition(),\n\t\t\t[index + 1]: points[index + 1].getPosition()\n\t\t};\n\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\tpoints[index].setPosition(_points[index]);\n\t\tpoints[index + 1].setPosition(_points[index + 1]);\n\t}\n\n\tdraggingEvent(event: MouseEvent, index: number) {\n\t\tlet points = this.props.link.getPoints();\n\t\t// get moving difference. Index + 1 will work because links indexes has\n\t\t// length = points.lenght - 1\n\t\tlet dx = Math.abs(points[index].getX() - points[index + 1].getX());\n\t\tlet dy = Math.abs(points[index].getY() - points[index + 1].getY());\n\n\t\t// moving with y direction\n\t\tif (dx === 0) {\n\t\t\tthis.calculatePositions(points, event, index, 'x');\n\t\t} else if (dy === 0) {\n\t\t\tthis.calculatePositions(points, event, index, 'y');\n\t\t}\n\t\tthis.props.link.setFirstAndLastPathsDirection();\n\t}\n\n\thandleMove = function (event: MouseEvent) {\n\t\tthis.draggingEvent(event, this.dragging_index);\n\t}.bind(this);\n\n\thandleUp = function (event: MouseEvent) {\n\t\t// Unregister handlers to avoid multiple event handlers for other links\n\t\tthis.setState({ canDrag: false, selected: false });\n\t\twindow.removeEventListener('mousemove', this.handleMove);\n\t\twindow.removeEventListener('mouseup', this.handleUp);\n\t}.bind(this);\n\n\trender() {\n\t\t//ensure id is present for all points on the path\n\t\tlet points = this.props.link.getPoints();\n\t\tlet paths = [];\n\n\t\t// Get points based on link orientation\n\t\tlet pointLeft = points[0];\n\t\tlet pointRight = points[points.length - 1];\n\t\tlet hadToSwitch = false;\n\t\tif (pointLeft.getX() > pointRight.getX()) {\n\t\t\tpointLeft = points[points.length - 1];\n\t\t\tpointRight = points[0];\n\t\t\thadToSwitch = true;\n\t\t}\n\t\tlet dy = Math.abs(points[0].getY() - points[points.length - 1].getY());\n\n\t\t// When new link add one middle point to get everywhere 90° angle\n\t\tif (this.props.link.getTargetPort() === null && points.length === 2) {\n\t\t\t[...Array(2)].forEach((item) => {\n\t\t\t\tthis.props.link.addPoint(\n\t\t\t\t\tnew PointModel({\n\t\t\t\t\t\tlink: this.props.link,\n\t\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\n\t\t\t\t\t}),\n\t\t\t\t\t1\n\t\t\t\t);\n\t\t\t});\n\t\t\tthis.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n\t\t}\n\t\t// When new link is moving and not connected to target port move with middle point\n\t\t// TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n\t\t//  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n\t\telse if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n\t\t\tpoints[1].setPosition(\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n\t\t\t\t!hadToSwitch ? pointLeft.getY() : pointRight.getY()\n\t\t\t);\n\t\t\tpoints[2].setPosition(\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n\t\t\t\t!hadToSwitch ? pointRight.getY() : pointLeft.getY()\n\t\t\t);\n\t\t}\n\t\t// Render was called but link is not moved but user.\n\t\t// Node is moved and in this case fix coordinates to get 90° angle.\n\t\t// For loop just for first and last path\n\t\telse if (!this.state.canDrag && points.length > 2) {\n\t\t\t// Those points and its position only will be moved\n\t\t\tfor (let i = 1; i < points.length; i += points.length - 2) {\n\t\t\t\tif (i - 1 === 0) {\n\t\t\t\t\tif (this.props.link.getFirstPathXdirection()) {\n\t\t\t\t\t\tpoints[i].setPosition(points[i].getX(), points[i - 1].getY());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoints[i].setPosition(points[i - 1].getX(), points[i].getY());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.props.link.getLastPathXdirection()) {\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If there is existing link which has two points add one\n\t\t// NOTE: It doesn't matter if check is for dy or dx\n\t\tif (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n\t\t\tthis.props.link.addPoint(\n\t\t\t\tnew PointModel({\n\t\t\t\t\tlink: this.props.link,\n\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tfor (let j = 0; j < points.length - 1; j++) {\n\t\t\tpaths.push(\n\t\t\t\tthis.generateLink(\n\t\t\t\t\tLinkWidget.generateLinePath(points[j], points[j + 1]),\n\t\t\t\t\t{\n\t\t\t\t\t\t'data-linkid': this.props.link.getID(),\n\t\t\t\t\t\t'data-point': j,\n\t\t\t\t\t\tonMouseDown: (event: MouseEvent) => {\n\t\t\t\t\t\t\tif (event.button === 0) {\n\t\t\t\t\t\t\t\tthis.setState({ canDrag: true });\n\t\t\t\t\t\t\t\tthis.dragging_index = j;\n\t\t\t\t\t\t\t\t// Register mouse move event to track mouse position\n\t\t\t\t\t\t\t\t// On mouse up these events are unregistered check \"this.handleUp\"\n\t\t\t\t\t\t\t\twindow.addEventListener('mousemove', this.handleMove);\n\t\t\t\t\t\t\t\twindow.addEventListener('mouseup', this.handleUp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonMouseEnter: (event: MouseEvent) => {\n\t\t\t\t\t\t\tthis.setState({ selected: true });\n\t\t\t\t\t\t\tthis.props.link.lastHoverIndexOfPath = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tj\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tthis.refPaths = [];\n\t\treturn <g data-default-link-test={this.props.link.getOptions().testName}>{paths}</g>;\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}
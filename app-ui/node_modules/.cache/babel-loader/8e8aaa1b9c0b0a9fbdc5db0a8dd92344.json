{"ast":null,"code":"/**\r\n * @author imor / https://github.com/imor\r\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\n\nvar DiagonalMovement = require('../core/DiagonalMovement');\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\n\n\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\n  JumpPointFinderBase.call(this, opt);\n}\n\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\n\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function (x, y, px, py) {\n  var grid = this.grid,\n      dx = x - px,\n      dy = y - py;\n\n  if (!grid.isWalkableAt(x, y)) {\n    return null;\n  }\n\n  if (this.trackJumpRecursion === true) {\n    grid.getNodeAt(x, y).tested = true;\n  }\n\n  if (grid.getNodeAt(x, y) === this.endNode) {\n    return [x, y];\n  } // check for forced neighbors\n  // along the diagonal\n\n\n  if (dx !== 0 && dy !== 0) {\n    // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\n    // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\n    // return [x, y];\n    // }\n    // when moving diagonally, must check for vertical/horizontal jump points\n    if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n      return [x, y];\n    }\n  } // horizontally/vertically\n  else {\n    if (dx !== 0) {\n      if (grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1) || grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1)) {\n        return [x, y];\n      }\n    } else if (dy !== 0) {\n      if (grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy) || grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy)) {\n        return [x, y];\n      } // When moving vertically, must check for horizontal jump points\n      // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\n      // return [x, y];\n      // }\n\n    }\n  } // moving diagonally, must make sure one of the vertical/horizontal\n  // neighbors is open to allow the path\n\n\n  if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\n    return this._jump(x + dx, y + dy, x, y);\n  } else {\n    return null;\n  }\n};\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\n\n\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function (node) {\n  var parent = node.parent,\n      x = node.x,\n      y = node.y,\n      grid = this.grid,\n      px,\n      py,\n      nx,\n      ny,\n      dx,\n      dy,\n      neighbors = [],\n      neighborNodes,\n      neighborNode,\n      i,\n      l; // directed pruning: can ignore most neighbors, unless forced.\n\n  if (parent) {\n    px = parent.x;\n    py = parent.y; // get the normalized direction of travel\n\n    dx = (x - px) / Math.max(Math.abs(x - px), 1);\n    dy = (y - py) / Math.max(Math.abs(y - py), 1); // search diagonally\n\n    if (dx !== 0 && dy !== 0) {\n      if (grid.isWalkableAt(x, y + dy)) {\n        neighbors.push([x, y + dy]);\n      }\n\n      if (grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y]);\n      }\n\n      if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y + dy]);\n      }\n    } // search horizontally/vertically\n    else {\n      var isNextWalkable;\n\n      if (dx !== 0) {\n        isNextWalkable = grid.isWalkableAt(x + dx, y);\n        var isTopWalkable = grid.isWalkableAt(x, y + 1);\n        var isBottomWalkable = grid.isWalkableAt(x, y - 1);\n\n        if (isNextWalkable) {\n          neighbors.push([x + dx, y]);\n\n          if (isTopWalkable) {\n            neighbors.push([x + dx, y + 1]);\n          }\n\n          if (isBottomWalkable) {\n            neighbors.push([x + dx, y - 1]);\n          }\n        }\n\n        if (isTopWalkable) {\n          neighbors.push([x, y + 1]);\n        }\n\n        if (isBottomWalkable) {\n          neighbors.push([x, y - 1]);\n        }\n      } else if (dy !== 0) {\n        isNextWalkable = grid.isWalkableAt(x, y + dy);\n        var isRightWalkable = grid.isWalkableAt(x + 1, y);\n        var isLeftWalkable = grid.isWalkableAt(x - 1, y);\n\n        if (isNextWalkable) {\n          neighbors.push([x, y + dy]);\n\n          if (isRightWalkable) {\n            neighbors.push([x + 1, y + dy]);\n          }\n\n          if (isLeftWalkable) {\n            neighbors.push([x - 1, y + dy]);\n          }\n        }\n\n        if (isRightWalkable) {\n          neighbors.push([x + 1, y]);\n        }\n\n        if (isLeftWalkable) {\n          neighbors.push([x - 1, y]);\n        }\n      }\n    }\n  } // return all neighbors\n  else {\n    neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\n\n    for (i = 0, l = neighborNodes.length; i < l; ++i) {\n      neighborNode = neighborNodes[i];\n      neighbors.push([neighborNode.x, neighborNode.y]);\n    }\n  }\n\n  return neighbors;\n};\n\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;","map":{"version":3,"sources":["C:/Users/nairr/app-ui/app-ui/node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js"],"names":["JumpPointFinderBase","require","DiagonalMovement","JPFMoveDiagonallyIfNoObstacles","opt","call","prototype","constructor","_jump","x","y","px","py","grid","dx","dy","isWalkableAt","trackJumpRecursion","getNodeAt","tested","endNode","_findNeighbors","node","parent","nx","ny","neighbors","neighborNodes","neighborNode","i","l","Math","max","abs","push","isNextWalkable","isTopWalkable","isBottomWalkable","isRightWalkable","isLeftWalkable","getNeighbors","OnlyWhenNoObstacles","length","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\r\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            // return [x, y];\r\n        // }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if (dx !== 0) {\r\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n                return [x, y];\r\n            }\r\n            // When moving vertically, must check for horizontal jump points\r\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n                // return [x, y];\r\n            // }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            var isNextWalkable;\r\n            if (dx !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\r\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\r\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (isTopWalkable) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (isBottomWalkable) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n                if (isTopWalkable) {\r\n                    neighbors.push([x, y + 1]);\r\n                }\r\n                if (isBottomWalkable) {\r\n                    neighbors.push([x, y - 1]);\r\n                }\r\n            }\r\n            else if (dy !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\r\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\r\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (isRightWalkable) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (isLeftWalkable) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n                if (isRightWalkable) {\r\n                    neighbors.push([x + 1, y]);\r\n                }\r\n                if (isLeftWalkable) {\r\n                    neighbors.push([x - 1, y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\r\n"]},"metadata":{},"sourceType":"script"}
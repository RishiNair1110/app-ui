{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathFindingLinkWidget = void 0;\n\nconst React = require(\"react\");\n\nconst _ = require(\"lodash\");\n\nconst PathFinding_1 = require(\"../engine/PathFinding\");\n\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\n\nclass PathFindingLinkWidget extends React.Component {\n  constructor(props) {\n    super(props);\n    this.refPaths = [];\n    this.state = {\n      selected: false\n    };\n    this.pathFinding = new PathFinding_1.PathFinding(this.props.factory);\n  }\n\n  componentDidUpdate() {\n    this.props.link.setRenderedPaths(this.refPaths.map(ref => {\n      return ref.current;\n    }));\n  }\n\n  componentDidMount() {\n    this.props.link.setRenderedPaths(this.refPaths.map(ref => {\n      return ref.current;\n    }));\n  }\n\n  componentWillUnmount() {\n    this.props.link.setRenderedPaths([]);\n  }\n\n  generateLink(path, id) {\n    const ref = React.createRef();\n    this.refPaths.push(ref);\n    return React.createElement(react_diagrams_defaults_1.DefaultLinkSegmentWidget, {\n      key: `link-${id}`,\n      path: path,\n      selected: this.state.selected,\n      diagramEngine: this.props.diagramEngine,\n      factory: this.props.diagramEngine.getFactoryForLink(this.props.link),\n      link: this.props.link,\n      forwardRef: ref,\n      onSelection: selected => {\n        this.setState({\n          selected: selected\n        });\n      },\n      extras: {}\n    });\n  }\n\n  render() {\n    this.refPaths = []; //ensure id is present for all points on the path\n\n    var points = this.props.link.getPoints();\n    var paths = []; // first step: calculate a direct path between the points being linked\n\n    const directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n    const routingMatrix = this.props.factory.getRoutingMatrix(); // now we need to extract, from the routing matrix, the very first walkable points\n    // so they can be used as origin and destination of the link to be created\n\n    const smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n\n    if (smartLink) {\n      const {\n        start,\n        end,\n        pathToStart,\n        pathToEnd\n      } = smartLink; // second step: calculate a path avoiding hitting other elements\n\n      const simplifiedPath = this.pathFinding.calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd);\n      paths.push( //smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n      this.generateLink(this.props.factory.generateDynamicPath(simplifiedPath), '0'));\n    }\n\n    return React.createElement(React.Fragment, null, paths);\n  }\n\n}\n\nexports.PathFindingLinkWidget = PathFindingLinkWidget;","map":{"version":3,"mappings":"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","names":["PathFindingLinkWidget","React","Component","constructor","props","refPaths","state","selected","pathFinding","PathFinding_1","factory","componentDidUpdate","link","setRenderedPaths","map","ref","current","componentDidMount","componentWillUnmount","generateLink","path","id","createRef","push","react_diagrams_defaults_1","key","diagramEngine","getFactoryForLink","forwardRef","onSelection","setState","extras","render","points","getPoints","paths","directPathCoords","calculateDirectPath","_","first","last","routingMatrix","getRoutingMatrix","smartLink","calculateLinkStartEndCoords","start","end","pathToStart","pathToEnd","simplifiedPath","calculateDynamicPath","generateDynamicPath","exports"],"sources":["C:\\Users\\nairr\\app-ui\\app-ui\\node_modules\\@projectstorm\\react-diagrams-routing\\src\\link\\PathFindingLinkWidget.tsx"],"sourcesContent":["import * as React from 'react';\nimport * as _ from 'lodash';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { PathFinding } from '../engine/PathFinding';\nimport { PathFindingLinkFactory } from './PathFindingLinkFactory';\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\nimport { DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\n\nexport interface PathFindingLinkWidgetProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: PathFindingLinkModel;\n\tdiagramEngine: DiagramEngine;\n\tfactory: PathFindingLinkFactory;\n}\n\nexport interface PathFindingLinkWidgetState {\n\tselected: boolean;\n}\n\nexport class PathFindingLinkWidget extends React.Component<PathFindingLinkWidgetProps, PathFindingLinkWidgetState> {\n\trefPaths: React.RefObject<SVGPathElement>[];\n\tpathFinding: PathFinding;\n\n\tconstructor(props: PathFindingLinkWidgetProps) {\n\t\tsuper(props);\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false\n\t\t};\n\t\tthis.pathFinding = new PathFinding(this.props.factory);\n\t}\n\n\tcomponentDidUpdate(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentDidMount(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.props.link.setRenderedPaths([]);\n\t}\n\n\tgenerateLink(path: string, id: string | number): JSX.Element {\n\t\tconst ref = React.createRef<SVGPathElement>();\n\t\tthis.refPaths.push(ref);\n\t\treturn (\n\t\t\t<DefaultLinkSegmentWidget\n\t\t\t\tkey={`link-${id}`}\n\t\t\t\tpath={path}\n\t\t\t\tselected={this.state.selected}\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n\t\t\t\tlink={this.props.link}\n\t\t\t\tforwardRef={ref}\n\t\t\t\tonSelection={(selected) => {\n\t\t\t\t\tthis.setState({ selected: selected });\n\t\t\t\t}}\n\t\t\t\textras={{}}\n\t\t\t/>\n\t\t);\n\t}\n\n\trender() {\n\t\tthis.refPaths = [];\n\t\t//ensure id is present for all points on the path\n\t\tvar points = this.props.link.getPoints();\n\t\tvar paths = [];\n\n\t\t// first step: calculate a direct path between the points being linked\n\t\tconst directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n\n\t\tconst routingMatrix = this.props.factory.getRoutingMatrix();\n\t\t// now we need to extract, from the routing matrix, the very first walkable points\n\t\t// so they can be used as origin and destination of the link to be created\n\t\tconst smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n\t\tif (smartLink) {\n\t\t\tconst { start, end, pathToStart, pathToEnd } = smartLink;\n\n\t\t\t// second step: calculate a path avoiding hitting other elements\n\t\t\tconst simplifiedPath = this.pathFinding.calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd);\n\n\t\t\tpaths.push(\n\t\t\t\t//smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n\t\t\t\tthis.generateLink(this.props.factory.generateDynamicPath(simplifiedPath), '0')\n\t\t\t);\n\t\t}\n\t\treturn <>{paths}</>;\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}
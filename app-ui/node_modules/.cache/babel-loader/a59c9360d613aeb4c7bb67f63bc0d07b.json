{"ast":null,"code":"/**\r\n * @author imor / https://github.com/imor\r\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\n\nvar DiagonalMovement = require('../core/DiagonalMovement');\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\n\n\nfunction JPFNeverMoveDiagonally(opt) {\n  JumpPointFinderBase.call(this, opt);\n}\n\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\n\nJPFNeverMoveDiagonally.prototype._jump = function (x, y, px, py) {\n  var grid = this.grid,\n      dx = x - px,\n      dy = y - py;\n\n  if (!grid.isWalkableAt(x, y)) {\n    return null;\n  }\n\n  if (this.trackJumpRecursion === true) {\n    grid.getNodeAt(x, y).tested = true;\n  }\n\n  if (grid.getNodeAt(x, y) === this.endNode) {\n    return [x, y];\n  }\n\n  if (dx !== 0) {\n    if (grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1) || grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1)) {\n      return [x, y];\n    }\n  } else if (dy !== 0) {\n    if (grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy) || grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy)) {\n      return [x, y];\n    } //When moving vertically, must check for horizontal jump points\n\n\n    if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\n      return [x, y];\n    }\n  } else {\n    throw new Error(\"Only horizontal and vertical movements are allowed\");\n  }\n\n  return this._jump(x + dx, y + dy, x, y);\n};\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\n\n\nJPFNeverMoveDiagonally.prototype._findNeighbors = function (node) {\n  var parent = node.parent,\n      x = node.x,\n      y = node.y,\n      grid = this.grid,\n      px,\n      py,\n      nx,\n      ny,\n      dx,\n      dy,\n      neighbors = [],\n      neighborNodes,\n      neighborNode,\n      i,\n      l; // directed pruning: can ignore most neighbors, unless forced.\n\n  if (parent) {\n    px = parent.x;\n    py = parent.y; // get the normalized direction of travel\n\n    dx = (x - px) / Math.max(Math.abs(x - px), 1);\n    dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n    if (dx !== 0) {\n      if (grid.isWalkableAt(x, y - 1)) {\n        neighbors.push([x, y - 1]);\n      }\n\n      if (grid.isWalkableAt(x, y + 1)) {\n        neighbors.push([x, y + 1]);\n      }\n\n      if (grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y]);\n      }\n    } else if (dy !== 0) {\n      if (grid.isWalkableAt(x - 1, y)) {\n        neighbors.push([x - 1, y]);\n      }\n\n      if (grid.isWalkableAt(x + 1, y)) {\n        neighbors.push([x + 1, y]);\n      }\n\n      if (grid.isWalkableAt(x, y + dy)) {\n        neighbors.push([x, y + dy]);\n      }\n    }\n  } // return all neighbors\n  else {\n    neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\n\n    for (i = 0, l = neighborNodes.length; i < l; ++i) {\n      neighborNode = neighborNodes[i];\n      neighbors.push([neighborNode.x, neighborNode.y]);\n    }\n  }\n\n  return neighbors;\n};\n\nmodule.exports = JPFNeverMoveDiagonally;","map":{"version":3,"sources":["C:/Users/nairr/app-ui/app-ui/node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js"],"names":["JumpPointFinderBase","require","DiagonalMovement","JPFNeverMoveDiagonally","opt","call","prototype","constructor","_jump","x","y","px","py","grid","dx","dy","isWalkableAt","trackJumpRecursion","getNodeAt","tested","endNode","Error","_findNeighbors","node","parent","nx","ny","neighbors","neighborNodes","neighborNode","i","l","Math","max","abs","push","getNeighbors","Never","length","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n"]},"metadata":{},"sourceType":"script"}
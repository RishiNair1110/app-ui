{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathFinding = void 0;\n\nconst PF = require(\"pathfinding\");\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\n\n\nconst pathFinderInstance = new PF.JumpPointFinder({\n  heuristic: PF.Heuristic.manhattan,\n  diagonalMovement: PF.DiagonalMovement.Never\n});\n\nclass PathFinding {\n  constructor(factory) {\n    this.instance = pathFinderInstance;\n    this.factory = factory;\n  }\n  /**\n   * Taking as argument a fully unblocked walking matrix, this method\n   * finds a direct path from point A to B.\n   */\n\n\n  calculateDirectPath(from, to) {\n    const matrix = this.factory.getCanvasMatrix();\n    const grid = new PF.Grid(matrix);\n    return pathFinderInstance.findPath(this.factory.translateRoutingX(Math.floor(from.getX() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingY(Math.floor(from.getY() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingX(Math.floor(to.getX() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingY(Math.floor(to.getY() / this.factory.ROUTING_SCALING_FACTOR)), grid);\n  }\n  /**\n   * Using @link{#calculateDirectPath}'s result as input, we here\n   * determine the first walkable point found in the matrix that includes\n   * blocked paths.\n   */\n\n\n  calculateLinkStartEndCoords(matrix, path) {\n    const startIndex = path.findIndex(point => {\n      if (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;else return false;\n    });\n    const endIndex = path.length - 1 - path.slice().reverse().findIndex(point => {\n      if (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;else return false;\n    }); // are we trying to create a path exclusively through blocked areas?\n    // if so, let's fallback to the linear routing\n\n    if (startIndex === -1 || endIndex === -1) {\n      return undefined;\n    }\n\n    const pathToStart = path.slice(0, startIndex);\n    const pathToEnd = path.slice(endIndex);\n    return {\n      start: {\n        x: path[startIndex][0],\n        y: path[startIndex][1]\n      },\n      end: {\n        x: path[endIndex][0],\n        y: path[endIndex][1]\n      },\n      pathToStart,\n      pathToEnd\n    };\n  }\n  /**\n   * Puts everything together: merges the paths from/to the centre of the ports,\n   * with the path calculated around other elements.\n   */\n\n\n  calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd) {\n    // generate the path based on the matrix with obstacles\n    const grid = new PF.Grid(routingMatrix);\n    const dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid); // aggregate everything to have the calculated path ready for rendering\n\n    const pathCoords = pathToStart.concat(dynamicPath, pathToEnd).map(coords => [this.factory.translateRoutingX(coords[0], true), this.factory.translateRoutingY(coords[1], true)]);\n    return PF.Util.compressPath(pathCoords);\n  }\n\n}\n\nexports.PathFinding = PathFinding;","map":{"version":3,"mappings":"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","names":["pathFinderInstance","PF","JumpPointFinder","heuristic","Heuristic","manhattan","diagonalMovement","DiagonalMovement","Never","PathFinding","constructor","factory","instance","calculateDirectPath","from","to","matrix","getCanvasMatrix","grid","Grid","findPath","translateRoutingX","Math","floor","getX","ROUTING_SCALING_FACTOR","translateRoutingY","getY","calculateLinkStartEndCoords","path","startIndex","findIndex","point","endIndex","length","slice","reverse","undefined","pathToStart","pathToEnd","start","x","y","end","calculateDynamicPath","routingMatrix","dynamicPath","pathCoords","concat","map","coords","Util","compressPath","exports"],"sources":["C:\\Users\\nairr\\app-ui\\app-ui\\node_modules\\@projectstorm\\react-diagrams-routing\\src\\engine\\PathFinding.ts"],"sourcesContent":["import * as PF from 'pathfinding';\nimport { PathFindingLinkFactory } from '../link/PathFindingLinkFactory';\nimport { PointModel } from '@projectstorm/react-diagrams-core';\n\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\n\nconst pathFinderInstance = new PF.JumpPointFinder({\n\theuristic: PF.Heuristic.manhattan,\n\tdiagonalMovement: PF.DiagonalMovement.Never\n});\n\nexport class PathFinding {\n\tinstance: any;\n\tfactory: PathFindingLinkFactory;\n\n\tconstructor(factory: PathFindingLinkFactory) {\n\t\tthis.instance = pathFinderInstance;\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Taking as argument a fully unblocked walking matrix, this method\n\t * finds a direct path from point A to B.\n\t */\n\tcalculateDirectPath(from: PointModel, to: PointModel): number[][] {\n\t\tconst matrix = this.factory.getCanvasMatrix();\n\t\tconst grid = new PF.Grid(matrix);\n\n\t\treturn pathFinderInstance.findPath(\n\t\t\tthis.factory.translateRoutingX(Math.floor(from.getX() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingY(Math.floor(from.getY() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingX(Math.floor(to.getX() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingY(Math.floor(to.getY() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tgrid\n\t\t);\n\t}\n\n\t/**\n\t * Using @link{#calculateDirectPath}'s result as input, we here\n\t * determine the first walkable point found in the matrix that includes\n\t * blocked paths.\n\t */\n\tcalculateLinkStartEndCoords(\n\t\tmatrix: number[][],\n\t\tpath: number[][]\n\t): {\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tpathToStart: number[][];\n\t\tpathToEnd: number[][];\n\t} {\n\t\tconst startIndex = path.findIndex((point) => {\n\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\n\t\t\telse return false;\n\t\t});\n\t\tconst endIndex =\n\t\t\tpath.length -\n\t\t\t1 -\n\t\t\tpath\n\t\t\t\t.slice()\n\t\t\t\t.reverse()\n\t\t\t\t.findIndex((point) => {\n\t\t\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\n\t\t\t\t\telse return false;\n\t\t\t\t});\n\n\t\t// are we trying to create a path exclusively through blocked areas?\n\t\t// if so, let's fallback to the linear routing\n\t\tif (startIndex === -1 || endIndex === -1) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst pathToStart = path.slice(0, startIndex);\n\t\tconst pathToEnd = path.slice(endIndex);\n\n\t\treturn {\n\t\t\tstart: {\n\t\t\t\tx: path[startIndex][0],\n\t\t\t\ty: path[startIndex][1]\n\t\t\t},\n\t\t\tend: {\n\t\t\t\tx: path[endIndex][0],\n\t\t\t\ty: path[endIndex][1]\n\t\t\t},\n\t\t\tpathToStart,\n\t\t\tpathToEnd\n\t\t};\n\t}\n\n\t/**\n\t * Puts everything together: merges the paths from/to the centre of the ports,\n\t * with the path calculated around other elements.\n\t */\n\tcalculateDynamicPath(\n\t\troutingMatrix: number[][],\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tpathToStart: number[][],\n\t\tpathToEnd: number[][]\n\t) {\n\t\t// generate the path based on the matrix with obstacles\n\t\tconst grid = new PF.Grid(routingMatrix);\n\t\tconst dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid);\n\n\t\t// aggregate everything to have the calculated path ready for rendering\n\t\tconst pathCoords = pathToStart\n\t\t\t.concat(dynamicPath, pathToEnd)\n\t\t\t.map((coords) => [\n\t\t\t\tthis.factory.translateRoutingX(coords[0], true),\n\t\t\t\tthis.factory.translateRoutingY(coords[1], true)\n\t\t\t]);\n\t\treturn PF.Util.compressPath(pathCoords);\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}
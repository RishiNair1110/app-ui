{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ZoomCanvasAction = void 0;\n\nconst Action_1 = require(\"../core-actions/Action\");\n\nclass ZoomCanvasAction extends Action_1.Action {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      type: Action_1.InputType.MOUSE_WHEEL,\n      fire: actionEvent => {\n        const {\n          event\n        } = actionEvent; // we can block layer rendering because we are only targeting the transforms\n\n        for (let layer of this.engine.getModel().getLayers()) {\n          layer.allowRepaint(false);\n        }\n\n        const model = this.engine.getModel();\n        event.stopPropagation();\n        const oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\n        let scrollDelta = options.inverseZoom ? -event.deltaY : event.deltaY; //check if it is pinch gesture\n\n        if (event.ctrlKey && scrollDelta % 1 !== 0) {\n          /*\n              Chrome and Firefox sends wheel event with deltaY that\n              have fractional part, also `ctrlKey` prop of the event is true\n              though ctrl isn't pressed\n          */\n          scrollDelta /= 3;\n        } else {\n          scrollDelta /= 60;\n        }\n\n        if (model.getZoomLevel() + scrollDelta > 10) {\n          model.setZoomLevel(model.getZoomLevel() + scrollDelta);\n        }\n\n        const zoomFactor = model.getZoomLevel() / 100;\n        const boundingRect = event.currentTarget.getBoundingClientRect();\n        const clientWidth = boundingRect.width;\n        const clientHeight = boundingRect.height; // compute difference between rect before and after scroll\n\n        const widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n        const heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor; // compute mouse coords relative to canvas\n\n        const clientX = event.clientX - boundingRect.left;\n        const clientY = event.clientY - boundingRect.top; // compute width and height increment factor\n\n        const xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\n        const yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\n        model.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\n        this.engine.repaintCanvas(); // re-enable rendering\n\n        for (let layer of this.engine.getModel().getLayers()) {\n          layer.allowRepaint(true);\n        }\n      }\n    });\n  }\n\n}\n\nexports.ZoomCanvasAction = ZoomCanvasAction;","map":{"version":3,"mappings":";;;;;;;AACA;;AAMA,MAAaA,gBAAb,SAAsCC,eAAtC,CAA4C;AAC3CC,gBAAiD;AAAA,QAArCC,OAAqC,uEAAF,EAAE;AAChD,UAAM;AACLC,UAAI,EAAEH,mBAAUI,WADX;AAELC,UAAI,EAAGC,WAAD,IAAyC;AAC9C,cAAM;AAAEC;AAAF,YAAYD,WAAlB,CAD8C,CAE9C;;AACA,aAAK,IAAIE,KAAT,IAAkB,KAAKC,MAAL,CAAYC,QAAZ,GAAuBC,SAAvB,EAAlB,EAAsD;AACrDH,eAAK,CAACI,YAAN,CAAmB,KAAnB;AACA;;AAED,cAAMC,KAAK,GAAG,KAAKJ,MAAL,CAAYC,QAAZ,EAAd;AACAH,aAAK,CAACO,eAAN;AACA,cAAMC,aAAa,GAAG,KAAKN,MAAL,CAAYC,QAAZ,GAAuBM,YAAvB,KAAwC,GAA9D;AACA,YAAIC,WAAW,GAAGf,OAAO,CAACgB,WAAR,GAAsB,CAACX,KAAK,CAACY,MAA7B,GAAsCZ,KAAK,CAACY,MAA9D,CAV8C,CAW9C;;AACA,YAAIZ,KAAK,CAACa,OAAN,IAAiBH,WAAW,GAAG,CAAd,KAAoB,CAAzC,EAA4C;AAC3C;;;;;AAKAA,qBAAW,IAAI,CAAf;AACA,SAPD,MAOO;AACNA,qBAAW,IAAI,EAAf;AACA;;AACD,YAAIJ,KAAK,CAACG,YAAN,KAAuBC,WAAvB,GAAqC,EAAzC,EAA6C;AAC5CJ,eAAK,CAACQ,YAAN,CAAmBR,KAAK,CAACG,YAAN,KAAuBC,WAA1C;AACA;;AAED,cAAMK,UAAU,GAAGT,KAAK,CAACG,YAAN,KAAuB,GAA1C;AAEA,cAAMO,YAAY,GAAGhB,KAAK,CAACiB,aAAN,CAAoBC,qBAApB,EAArB;AACA,cAAMC,WAAW,GAAGH,YAAY,CAACI,KAAjC;AACA,cAAMC,YAAY,GAAGL,YAAY,CAACM,MAAlC,CA9B8C,CA+B9C;;AACA,cAAMC,SAAS,GAAGJ,WAAW,GAAGJ,UAAd,GAA2BI,WAAW,GAAGX,aAA3D;AACA,cAAMgB,UAAU,GAAGH,YAAY,GAAGN,UAAf,GAA4BM,YAAY,GAAGb,aAA9D,CAjC8C,CAkC9C;;AACA,cAAMiB,OAAO,GAAGzB,KAAK,CAACyB,OAAN,GAAgBT,YAAY,CAACU,IAA7C;AACA,cAAMC,OAAO,GAAG3B,KAAK,CAAC2B,OAAN,GAAgBX,YAAY,CAACY,GAA7C,CApC8C,CAsC9C;;AACA,cAAMC,OAAO,GAAG,CAACJ,OAAO,GAAGnB,KAAK,CAACwB,UAAN,EAAX,IAAiCtB,aAAjC,GAAiDW,WAAjE;AACA,cAAMY,OAAO,GAAG,CAACJ,OAAO,GAAGrB,KAAK,CAAC0B,UAAN,EAAX,IAAiCxB,aAAjC,GAAiDa,YAAjE;AAEAf,aAAK,CAAC2B,SAAN,CAAgB3B,KAAK,CAACwB,UAAN,KAAqBP,SAAS,GAAGM,OAAjD,EAA0DvB,KAAK,CAAC0B,UAAN,KAAqBR,UAAU,GAAGO,OAA5F;AACA,aAAK7B,MAAL,CAAYgC,aAAZ,GA3C8C,CA6C9C;;AACA,aAAK,IAAIjC,KAAT,IAAkB,KAAKC,MAAL,CAAYC,QAAZ,GAAuBC,SAAvB,EAAlB,EAAsD;AACrDH,eAAK,CAACI,YAAN,CAAmB,IAAnB;AACA;AACD;AAnDI,KAAN;AAqDA;;AAvD0C;;AAA5C8B","names":["ZoomCanvasAction","Action_1","constructor","options","type","MOUSE_WHEEL","fire","actionEvent","event","layer","engine","getModel","getLayers","allowRepaint","model","stopPropagation","oldZoomFactor","getZoomLevel","scrollDelta","inverseZoom","deltaY","ctrlKey","setZoomLevel","zoomFactor","boundingRect","currentTarget","getBoundingClientRect","clientWidth","width","clientHeight","height","widthDiff","heightDiff","clientX","left","clientY","top","xFactor","getOffsetX","yFactor","getOffsetY","setOffset","repaintCanvas","exports"],"sources":["C:\\Users\\nairr\\app-ui\\app-ui\\node_modules\\@projectstorm\\react-canvas-core\\src\\actions\\ZoomCanvasAction.ts"],"sourcesContent":["import { WheelEvent } from 'react';\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\n\nexport interface ZoomCanvasActionOptions {\n\tinverseZoom?: boolean;\n}\n\nexport class ZoomCanvasAction extends Action {\n\tconstructor(options: ZoomCanvasActionOptions = {}) {\n\t\tsuper({\n\t\t\ttype: InputType.MOUSE_WHEEL,\n\t\t\tfire: (actionEvent: ActionEvent<WheelEvent>) => {\n\t\t\t\tconst { event } = actionEvent;\n\t\t\t\t// we can block layer rendering because we are only targeting the transforms\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\n\t\t\t\t\tlayer.allowRepaint(false);\n\t\t\t\t}\n\n\t\t\t\tconst model = this.engine.getModel();\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tconst oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\n\t\t\t\tlet scrollDelta = options.inverseZoom ? -event.deltaY : event.deltaY;\n\t\t\t\t//check if it is pinch gesture\n\t\t\t\tif (event.ctrlKey && scrollDelta % 1 !== 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tChrome and Firefox sends wheel event with deltaY that\n\t\t\t\t\t\thave fractional part, also `ctrlKey` prop of the event is true\n\t\t\t\t\t\tthough ctrl isn't pressed\n\t\t\t\t\t*/\n\t\t\t\t\tscrollDelta /= 3;\n\t\t\t\t} else {\n\t\t\t\t\tscrollDelta /= 60;\n\t\t\t\t}\n\t\t\t\tif (model.getZoomLevel() + scrollDelta > 10) {\n\t\t\t\t\tmodel.setZoomLevel(model.getZoomLevel() + scrollDelta);\n\t\t\t\t}\n\n\t\t\t\tconst zoomFactor = model.getZoomLevel() / 100;\n\n\t\t\t\tconst boundingRect = event.currentTarget.getBoundingClientRect();\n\t\t\t\tconst clientWidth = boundingRect.width;\n\t\t\t\tconst clientHeight = boundingRect.height;\n\t\t\t\t// compute difference between rect before and after scroll\n\t\t\t\tconst widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n\t\t\t\tconst heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\n\t\t\t\t// compute mouse coords relative to canvas\n\t\t\t\tconst clientX = event.clientX - boundingRect.left;\n\t\t\t\tconst clientY = event.clientY - boundingRect.top;\n\n\t\t\t\t// compute width and height increment factor\n\t\t\t\tconst xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\n\t\t\t\tconst yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\n\n\t\t\t\tmodel.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\n\t\t\t\tthis.engine.repaintCanvas();\n\n\t\t\t\t// re-enable rendering\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\n\t\t\t\t\tlayer.allowRepaint(true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathFindingLinkFactory = void 0;\n\nconst React = require(\"react\");\n\nconst PathFindingLinkModel_1 = require(\"./PathFindingLinkModel\");\n\nconst PathFindingLinkWidget_1 = require(\"./PathFindingLinkWidget\");\n\nconst _ = require(\"lodash\");\n\nconst Path = require(\"paths-js/path\");\n\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\n\nconst react_canvas_core_1 = require(\"@projectstorm/react-canvas-core\");\n\nclass PathFindingLinkFactory extends react_diagrams_defaults_1.DefaultLinkFactory {\n  constructor() {\n    super(PathFindingLinkFactory.NAME);\n    this.ROUTING_SCALING_FACTOR = 5; // calculated only when smart routing is active\n\n    this.canvasMatrix = [];\n    this.routingMatrix = []; // used when at least one element has negative coordinates\n\n    this.hAdjustmentFactor = 0;\n    this.vAdjustmentFactor = 0;\n    /**\n     * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n     * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n     */\n\n    this.calculateMatrixDimensions = () => {\n      const allNodesCoords = _.values(this.engine.getModel().getNodes()).map(item => ({\n        x: item.getX(),\n        width: item.width,\n        y: item.getY(),\n        height: item.height\n      }));\n\n      const allLinks = _.values(this.engine.getModel().getLinks());\n\n      const allPortsCoords = _.flatMap(allLinks.map(link => [link.getSourcePort(), link.getTargetPort()])).filter(port => port !== null).map(item => ({\n        x: item.getX(),\n        width: item.width,\n        y: item.getY(),\n        height: item.height\n      }));\n\n      const allPointsCoords = _.flatMap(allLinks.map(link => link.getPoints())).map(item => ({\n        // points don't have width/height, so let's just use 0\n        x: item.getX(),\n        width: 0,\n        y: item.getY(),\n        height: 0\n      }));\n\n      const sumProps = (object, props) => _.reduce(props, (acc, prop) => acc + _.get(object, prop, 0), 0);\n\n      const canvas = this.engine.getCanvas();\n\n      const concatedCoords = _.concat(allNodesCoords, allPortsCoords, allPointsCoords);\n\n      const minX = Math.floor(Math.min(_.get(_.minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n\n      const maxXElement = _.maxBy(concatedCoords, item => sumProps(item, ['x', 'width']));\n\n      const maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n\n      const minYCoords = _.minBy(concatedCoords, 'y');\n\n      const minY = Math.floor(Math.min(_.get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n\n      const maxYElement = _.maxBy(concatedCoords, item => sumProps(item, ['y', 'height']));\n\n      const maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n      return {\n        width: Math.ceil(Math.abs(minX) + maxX),\n        hAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n        height: Math.ceil(Math.abs(minY) + maxY),\n        vAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n      };\n    };\n    /**\n     * Updates (by reference) where nodes will be drawn on the matrix passed in.\n     */\n\n\n    this.markNodes = matrix => {\n      _.values(this.engine.getModel().getNodes()).forEach(node => {\n        const startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n        const endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n        const startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n        const endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n\n        for (let x = startX - 1; x <= endX + 1; x++) {\n          for (let y = startY - 1; y < endY + 1; y++) {\n            this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n          }\n        }\n      });\n    };\n    /**\n     * Updates (by reference) where ports will be drawn on the matrix passed in.\n     */\n\n\n    this.markPorts = matrix => {\n      const allElements = _.flatMap(_.values(this.engine.getModel().getLinks()).map(link => [].concat(link.getSourcePort(), link.getTargetPort())));\n\n      allElements.filter(port => port !== null).forEach(port => {\n        const startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n        const endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n        const startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n        const endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n\n        for (let x = startX - 1; x <= endX + 1; x++) {\n          for (let y = startY - 1; y < endY + 1; y++) {\n            this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n          }\n        }\n      });\n    };\n\n    this.markMatrixPoint = (matrix, x, y) => {\n      if (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n        matrix[y][x] = 1;\n      }\n    };\n  }\n\n  setDiagramEngine(engine) {\n    super.setDiagramEngine(engine); // listen for drag changes\n\n    engine.getStateMachine().registerListener({\n      stateChanged: event => {\n        if (event.newState instanceof react_canvas_core_1.AbstractDisplacementState) {\n          const deRegister = engine.getActionEventBus().registerAction(new react_canvas_core_1.Action({\n            type: react_canvas_core_1.InputType.MOUSE_UP,\n            fire: () => {\n              this.calculateRoutingMatrix();\n              engine.repaintCanvas();\n              deRegister();\n            }\n          }));\n        }\n      }\n    });\n    this.listener = engine.registerListener({\n      canvasReady: () => {\n        _.defer(() => {\n          this.calculateRoutingMatrix();\n          engine.repaintCanvas();\n        });\n      }\n    });\n  }\n\n  setFactoryBank(bank) {\n    super.setFactoryBank(bank);\n\n    if (!bank && this.listener) {\n      this.listener.deregister();\n    }\n  }\n\n  generateReactWidget(event) {\n    return React.createElement(PathFindingLinkWidget_1.PathFindingLinkWidget, {\n      diagramEngine: this.engine,\n      link: event.model,\n      factory: this\n    });\n  }\n\n  generateModel(event) {\n    return new PathFindingLinkModel_1.PathFindingLinkModel();\n  }\n  /**\n   * A representation of the canvas in the following format:\n   *\n   * +-----------------+\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * +-----------------+\n   *\n   * In which all walkable points are marked by zeros.\n   * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n   */\n\n\n  getCanvasMatrix() {\n    if (this.canvasMatrix.length === 0) {\n      this.calculateCanvasMatrix();\n    }\n\n    return this.canvasMatrix;\n  }\n\n  calculateCanvasMatrix() {\n    const {\n      width: canvasWidth,\n      hAdjustmentFactor,\n      height: canvasHeight,\n      vAdjustmentFactor\n    } = this.calculateMatrixDimensions();\n    this.hAdjustmentFactor = hAdjustmentFactor;\n    this.vAdjustmentFactor = vAdjustmentFactor;\n    const matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n    const matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n    this.canvasMatrix = _.range(0, matrixHeight).map(() => {\n      return new Array(matrixWidth).fill(0);\n    });\n  }\n  /**\n   * A representation of the canvas in the following format:\n   *\n   * +-----------------+\n   * | 0 0 1 1 0 0 0 0 |\n   * | 0 0 1 1 0 0 1 1 |\n   * | 0 0 0 0 0 0 1 1 |\n   * | 1 1 0 0 0 0 0 0 |\n   * | 1 1 0 0 0 0 0 0 |\n   * +-----------------+\n   *\n   * In which all points blocked by a node (and its ports) are\n   * marked as 1; points were there is nothing (ie, free) receive 0.\n   */\n\n\n  getRoutingMatrix() {\n    if (this.routingMatrix.length === 0) {\n      this.calculateRoutingMatrix();\n    }\n\n    return this.routingMatrix;\n  }\n\n  calculateRoutingMatrix() {\n    const matrix = _.cloneDeep(this.getCanvasMatrix()); // nodes need to be marked as blocked points\n\n\n    this.markNodes(matrix); // same thing for ports\n\n    this.markPorts(matrix);\n    this.routingMatrix = matrix;\n  }\n  /**\n   * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n   * We use the functions below to translate back and forth between these coordinates, relying on the\n   * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n   */\n\n\n  translateRoutingX(x) {\n    let reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n  }\n\n  translateRoutingY(y) {\n    let reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n  }\n\n  generateDynamicPath(pathCoords) {\n    let path = Path();\n    path = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n    pathCoords.slice(1).forEach(coords => {\n      path = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n    });\n    return path.print();\n  }\n\n}\n\nexports.PathFindingLinkFactory = PathFindingLinkFactory;\nPathFindingLinkFactory.NAME = 'pathfinding';","map":{"version":3,"mappings":"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","names":["PathFindingLinkFactory","react_diagrams_defaults_1","constructor","NAME","allNodesCoords","_","values","engine","getModel","getNodes","map","item","x","getX","width","y","getY","height","allLinks","getLinks","allPortsCoords","flatMap","link","getSourcePort","getTargetPort","filter","port","allPointsCoords","getPoints","sumProps","object","props","reduce","acc","prop","get","canvas","getCanvas","concatedCoords","concat","minX","Math","floor","min","minBy","ROUTING_SCALING_FACTOR","maxXElement","maxBy","maxX","max","offsetWidth","minYCoords","minY","maxYElement","maxY","offsetHeight","ceil","abs","hAdjustmentFactor","vAdjustmentFactor","matrix","forEach","node","startX","endX","startY","endY","markMatrixPoint","translateRoutingX","translateRoutingY","allElements","undefined","setDiagramEngine","getStateMachine","registerListener","stateChanged","event","newState","react_canvas_core_1","deRegister","getActionEventBus","registerAction","type","MOUSE_UP","fire","calculateRoutingMatrix","repaintCanvas","listener","canvasReady","defer","setFactoryBank","bank","deregister","generateReactWidget","React","PathFindingLinkWidget_1","diagramEngine","model","factory","generateModel","PathFindingLinkModel_1","getCanvasMatrix","canvasMatrix","length","calculateCanvasMatrix","canvasWidth","canvasHeight","calculateMatrixDimensions","matrixWidth","matrixHeight","range","Array","fill","getRoutingMatrix","routingMatrix","cloneDeep","markNodes","markPorts","reverse","generateDynamicPath","pathCoords","path","Path","moveto","slice","coords","lineto","print","exports"],"sources":["C:\\Users\\nairr\\app-ui\\app-ui\\node_modules\\@projectstorm\\react-diagrams-routing\\src\\link\\PathFindingLinkFactory.tsx"],"sourcesContent":["import * as React from 'react';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\nimport { PathFindingLinkWidget } from './PathFindingLinkWidget';\nimport * as _ from 'lodash';\nimport * as Path from 'paths-js/path';\nimport { DefaultLinkFactory } from '@projectstorm/react-diagrams-defaults';\nimport {\n\tAbstractDisplacementState,\n\tAbstractFactory,\n\tAction,\n\tFactoryBank,\n\tInputType,\n\tListenerHandle\n} from '@projectstorm/react-canvas-core';\n\nexport class PathFindingLinkFactory extends DefaultLinkFactory<PathFindingLinkModel> {\n\tROUTING_SCALING_FACTOR: number = 5;\n\n\t// calculated only when smart routing is active\n\tcanvasMatrix: number[][] = [];\n\troutingMatrix: number[][] = [];\n\n\t// used when at least one element has negative coordinates\n\thAdjustmentFactor: number = 0;\n\tvAdjustmentFactor: number = 0;\n\n\tstatic NAME = 'pathfinding';\n\tlistener: ListenerHandle;\n\n\tconstructor() {\n\t\tsuper(PathFindingLinkFactory.NAME);\n\t}\n\n\tsetDiagramEngine(engine: DiagramEngine): void {\n\t\tsuper.setDiagramEngine(engine);\n\n\t\t// listen for drag changes\n\t\tengine.getStateMachine().registerListener({\n\t\t\tstateChanged: (event) => {\n\t\t\t\tif (event.newState instanceof AbstractDisplacementState) {\n\t\t\t\t\tconst deRegister = engine.getActionEventBus().registerAction(\n\t\t\t\t\t\tnew Action<DiagramEngine>({\n\t\t\t\t\t\t\ttype: InputType.MOUSE_UP,\n\t\t\t\t\t\t\tfire: () => {\n\t\t\t\t\t\t\t\tthis.calculateRoutingMatrix();\n\t\t\t\t\t\t\t\tengine.repaintCanvas();\n\t\t\t\t\t\t\t\tdeRegister();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.listener = engine.registerListener({\n\t\t\tcanvasReady: () => {\n\t\t\t\t_.defer(() => {\n\t\t\t\t\tthis.calculateRoutingMatrix();\n\t\t\t\t\tengine.repaintCanvas();\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tsetFactoryBank(bank: FactoryBank<AbstractFactory>): void {\n\t\tsuper.setFactoryBank(bank);\n\t\tif (!bank && this.listener) {\n\t\t\tthis.listener.deregister();\n\t\t}\n\t}\n\n\tgenerateReactWidget(event): JSX.Element {\n\t\treturn <PathFindingLinkWidget diagramEngine={this.engine} link={event.model} factory={this} />;\n\t}\n\n\tgenerateModel(event): PathFindingLinkModel {\n\t\treturn new PathFindingLinkModel();\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all walkable points are marked by zeros.\n\t * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n\t */\n\tgetCanvasMatrix(): number[][] {\n\t\tif (this.canvasMatrix.length === 0) {\n\t\t\tthis.calculateCanvasMatrix();\n\t\t}\n\n\t\treturn this.canvasMatrix;\n\t}\n\tcalculateCanvasMatrix() {\n\t\tconst {\n\t\t\twidth: canvasWidth,\n\t\t\thAdjustmentFactor,\n\t\t\theight: canvasHeight,\n\t\t\tvAdjustmentFactor\n\t\t} = this.calculateMatrixDimensions();\n\n\t\tthis.hAdjustmentFactor = hAdjustmentFactor;\n\t\tthis.vAdjustmentFactor = vAdjustmentFactor;\n\n\t\tconst matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n\t\tconst matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n\n\t\tthis.canvasMatrix = _.range(0, matrixHeight).map(() => {\n\t\t\treturn new Array(matrixWidth).fill(0);\n\t\t});\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 1 1 0 0 0 0 |\n\t * | 0 0 1 1 0 0 1 1 |\n\t * | 0 0 0 0 0 0 1 1 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all points blocked by a node (and its ports) are\n\t * marked as 1; points were there is nothing (ie, free) receive 0.\n\t */\n\tgetRoutingMatrix(): number[][] {\n\t\tif (this.routingMatrix.length === 0) {\n\t\t\tthis.calculateRoutingMatrix();\n\t\t}\n\n\t\treturn this.routingMatrix;\n\t}\n\tcalculateRoutingMatrix(): void {\n\t\tconst matrix = _.cloneDeep(this.getCanvasMatrix());\n\n\t\t// nodes need to be marked as blocked points\n\t\tthis.markNodes(matrix);\n\t\t// same thing for ports\n\t\tthis.markPorts(matrix);\n\n\t\tthis.routingMatrix = matrix;\n\t}\n\n\t/**\n\t * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n\t * We use the functions below to translate back and forth between these coordinates, relying on the\n\t * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n\t */\n\ttranslateRoutingX(x: number, reverse: boolean = false) {\n\t\treturn x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\ttranslateRoutingY(y: number, reverse: boolean = false) {\n\t\treturn y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\n\t/**\n\t * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n\t * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n\t */\n\tcalculateMatrixDimensions = (): {\n\t\twidth: number;\n\t\thAdjustmentFactor: number;\n\t\theight: number;\n\t\tvAdjustmentFactor: number;\n\t} => {\n\t\tconst allNodesCoords = _.values(this.engine.getModel().getNodes()).map((item) => ({\n\t\t\tx: item.getX(),\n\t\t\twidth: item.width,\n\t\t\ty: item.getY(),\n\t\t\theight: item.height\n\t\t}));\n\n\t\tconst allLinks = _.values(this.engine.getModel().getLinks());\n\t\tconst allPortsCoords = _.flatMap(allLinks.map((link) => [link.getSourcePort(), link.getTargetPort()]))\n\t\t\t.filter((port) => port !== null)\n\t\t\t.map((item) => ({\n\t\t\t\tx: item.getX(),\n\t\t\t\twidth: item.width,\n\t\t\t\ty: item.getY(),\n\t\t\t\theight: item.height\n\t\t\t}));\n\t\tconst allPointsCoords = _.flatMap(allLinks.map((link) => link.getPoints())).map((item) => ({\n\t\t\t// points don't have width/height, so let's just use 0\n\t\t\tx: item.getX(),\n\t\t\twidth: 0,\n\t\t\ty: item.getY(),\n\t\t\theight: 0\n\t\t}));\n\n\t\tconst sumProps = (object, props) => _.reduce(props, (acc, prop) => acc + _.get(object, prop, 0), 0);\n\n\t\tconst canvas = this.engine.getCanvas() as HTMLDivElement;\n\t\tconst concatedCoords = _.concat(allNodesCoords, allPortsCoords, allPointsCoords);\n\t\tconst minX =\n\t\t\tMath.floor(Math.min(_.get(_.minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) *\n\t\t\tthis.ROUTING_SCALING_FACTOR;\n\t\tconst maxXElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['x', 'width']));\n\t\tconst maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n\t\tconst minYCoords = _.minBy(concatedCoords, 'y');\n\t\tconst minY =\n\t\t\tMath.floor(Math.min(_.get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n\t\tconst maxYElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['y', 'height']));\n\t\tconst maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n\n\t\treturn {\n\t\t\twidth: Math.ceil(Math.abs(minX) + maxX),\n\t\t\thAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n\t\t\theight: Math.ceil(Math.abs(minY) + maxY),\n\t\t\tvAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n\t\t};\n\t};\n\n\t/**\n\t * Updates (by reference) where nodes will be drawn on the matrix passed in.\n\t */\n\tmarkNodes = (matrix: number[][]): void => {\n\t\t_.values(this.engine.getModel().getNodes()).forEach((node) => {\n\t\t\tconst startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n\n\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Updates (by reference) where ports will be drawn on the matrix passed in.\n\t */\n\tmarkPorts = (matrix: number[][]): void => {\n\t\tconst allElements = _.flatMap(\n\t\t\t_.values(this.engine.getModel().getLinks()).map((link) => [].concat(link.getSourcePort(), link.getTargetPort()))\n\t\t);\n\t\tallElements\n\t\t\t.filter((port) => port !== null)\n\t\t\t.forEach((port) => {\n\t\t\t\tconst startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n\n\t\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t};\n\n\tmarkMatrixPoint = (matrix: number[][], x: number, y: number) => {\n\t\tif (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n\t\t\tmatrix[y][x] = 1;\n\t\t}\n\t};\n\n\tgenerateDynamicPath(pathCoords: number[][]) {\n\t\tlet path = Path();\n\t\tpath = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n\t\tpathCoords.slice(1).forEach((coords) => {\n\t\t\tpath = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n\t\t});\n\t\treturn path.print();\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}
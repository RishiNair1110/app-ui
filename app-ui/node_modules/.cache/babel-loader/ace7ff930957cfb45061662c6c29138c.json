{"ast":null,"code":"/**\r\n * @author imor / https://github.com/imor\r\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\n\nvar DiagonalMovement = require('../core/DiagonalMovement');\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\n\n\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\n  JumpPointFinderBase.call(this, opt);\n}\n\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\n\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function (x, y, px, py) {\n  var grid = this.grid,\n      dx = x - px,\n      dy = y - py;\n\n  if (!grid.isWalkableAt(x, y)) {\n    return null;\n  }\n\n  if (this.trackJumpRecursion === true) {\n    grid.getNodeAt(x, y).tested = true;\n  }\n\n  if (grid.getNodeAt(x, y) === this.endNode) {\n    return [x, y];\n  } // check for forced neighbors\n  // along the diagonal\n\n\n  if (dx !== 0 && dy !== 0) {\n    if (grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y) || grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy)) {\n      return [x, y];\n    } // when moving diagonally, must check for vertical/horizontal jump points\n\n\n    if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n      return [x, y];\n    }\n  } // horizontally/vertically\n  else {\n    if (dx !== 0) {\n      // moving along x\n      if (grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1) || grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1)) {\n        return [x, y];\n      }\n    } else {\n      if (grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y) || grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y)) {\n        return [x, y];\n      }\n    }\n  } // moving diagonally, must make sure one of the vertical/horizontal\n  // neighbors is open to allow the path\n\n\n  if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\n    return this._jump(x + dx, y + dy, x, y);\n  } else {\n    return null;\n  }\n};\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\n\n\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function (node) {\n  var parent = node.parent,\n      x = node.x,\n      y = node.y,\n      grid = this.grid,\n      px,\n      py,\n      nx,\n      ny,\n      dx,\n      dy,\n      neighbors = [],\n      neighborNodes,\n      neighborNode,\n      i,\n      l; // directed pruning: can ignore most neighbors, unless forced.\n\n  if (parent) {\n    px = parent.x;\n    py = parent.y; // get the normalized direction of travel\n\n    dx = (x - px) / Math.max(Math.abs(x - px), 1);\n    dy = (y - py) / Math.max(Math.abs(y - py), 1); // search diagonally\n\n    if (dx !== 0 && dy !== 0) {\n      if (grid.isWalkableAt(x, y + dy)) {\n        neighbors.push([x, y + dy]);\n      }\n\n      if (grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y]);\n      }\n\n      if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y + dy]);\n      }\n\n      if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\n        neighbors.push([x - dx, y + dy]);\n      }\n\n      if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\n        neighbors.push([x + dx, y - dy]);\n      }\n    } // search horizontally/vertically\n    else {\n      if (dx === 0) {\n        if (grid.isWalkableAt(x, y + dy)) {\n          neighbors.push([x, y + dy]);\n\n          if (!grid.isWalkableAt(x + 1, y)) {\n            neighbors.push([x + 1, y + dy]);\n          }\n\n          if (!grid.isWalkableAt(x - 1, y)) {\n            neighbors.push([x - 1, y + dy]);\n          }\n        }\n      } else {\n        if (grid.isWalkableAt(x + dx, y)) {\n          neighbors.push([x + dx, y]);\n\n          if (!grid.isWalkableAt(x, y + 1)) {\n            neighbors.push([x + dx, y + 1]);\n          }\n\n          if (!grid.isWalkableAt(x, y - 1)) {\n            neighbors.push([x + dx, y - 1]);\n          }\n        }\n      }\n    }\n  } // return all neighbors\n  else {\n    neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\n\n    for (i = 0, l = neighborNodes.length; i < l; ++i) {\n      neighborNode = neighborNodes[i];\n      neighbors.push([neighborNode.x, neighborNode.y]);\n    }\n  }\n\n  return neighbors;\n};\n\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;","map":{"version":3,"sources":["C:/Users/nairr/app-ui/app-ui/node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js"],"names":["JumpPointFinderBase","require","DiagonalMovement","JPFMoveDiagonallyIfAtMostOneObstacle","opt","call","prototype","constructor","_jump","x","y","px","py","grid","dx","dy","isWalkableAt","trackJumpRecursion","getNodeAt","tested","endNode","_findNeighbors","node","parent","nx","ny","neighbors","neighborNodes","neighborNode","i","l","Math","max","abs","push","getNeighbors","IfAtMostOneObstacle","length","module","exports"],"mappings":"AAAA;AACA;AACA;AACA,IAAIA,mBAAmB,GAAGC,OAAO,CAAC,uBAAD,CAAjC;;AACA,IAAIC,gBAAgB,GAAGD,OAAO,CAAC,0BAAD,CAA9B;AAEA;AACA;AACA;AACA;;;AACA,SAASE,oCAAT,CAA8CC,GAA9C,EAAmD;AAC/CJ,EAAAA,mBAAmB,CAACK,IAApB,CAAyB,IAAzB,EAA+BD,GAA/B;AACH;;AAEDD,oCAAoC,CAACG,SAArC,GAAiD,IAAIN,mBAAJ,EAAjD;AACAG,oCAAoC,CAACG,SAArC,CAA+CC,WAA/C,GAA6DJ,oCAA7D;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,oCAAoC,CAACG,SAArC,CAA+CE,KAA/C,GAAuD,UAASC,CAAT,EAAYC,CAAZ,EAAeC,EAAf,EAAmBC,EAAnB,EAAuB;AAC1E,MAAIC,IAAI,GAAG,KAAKA,IAAhB;AAAA,MACIC,EAAE,GAAGL,CAAC,GAAGE,EADb;AAAA,MACiBI,EAAE,GAAGL,CAAC,GAAGE,EAD1B;;AAGA,MAAI,CAACC,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAArB,CAAL,EAA8B;AAC1B,WAAO,IAAP;AACH;;AAED,MAAG,KAAKO,kBAAL,KAA4B,IAA/B,EAAqC;AACjCJ,IAAAA,IAAI,CAACK,SAAL,CAAeT,CAAf,EAAkBC,CAAlB,EAAqBS,MAArB,GAA8B,IAA9B;AACH;;AAED,MAAIN,IAAI,CAACK,SAAL,CAAeT,CAAf,EAAkBC,CAAlB,MAAyB,KAAKU,OAAlC,EAA2C;AACvC,WAAO,CAACX,CAAD,EAAIC,CAAJ,CAAP;AACH,GAdyE,CAgB1E;AACA;;;AACA,MAAII,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvB,EAA0B;AACtB,QAAKF,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAGK,EAAtB,EAA0BJ,CAAC,GAAGK,EAA9B,KAAqC,CAACF,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAGK,EAAtB,EAA0BJ,CAA1B,CAAvC,IACCG,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAGK,EAAtB,EAA0BJ,CAAC,GAAGK,EAA9B,KAAqC,CAACF,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAAC,GAAGK,EAAzB,CAD3C,EAC0E;AACtE,aAAO,CAACN,CAAD,EAAIC,CAAJ,CAAP;AACH,KAJqB,CAKtB;;;AACA,QAAI,KAAKF,KAAL,CAAWC,CAAC,GAAGK,EAAf,EAAmBJ,CAAnB,EAAsBD,CAAtB,EAAyBC,CAAzB,KAA+B,KAAKF,KAAL,CAAWC,CAAX,EAAcC,CAAC,GAAGK,EAAlB,EAAsBN,CAAtB,EAAyBC,CAAzB,CAAnC,EAAgE;AAC5D,aAAO,CAACD,CAAD,EAAIC,CAAJ,CAAP;AACH;AACJ,GATD,CAUA;AAVA,OAWK;AACD,QAAII,EAAE,KAAK,CAAX,EAAe;AAAE;AACb,UAAID,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAGK,EAAtB,EAA0BJ,CAAC,GAAG,CAA9B,KAAoC,CAACG,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAAC,GAAG,CAAzB,CAAtC,IACCG,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAGK,EAAtB,EAA0BJ,CAAC,GAAG,CAA9B,KAAoC,CAACG,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAAC,GAAG,CAAzB,CADzC,EACuE;AACnE,eAAO,CAACD,CAAD,EAAIC,CAAJ,CAAP;AACH;AACJ,KALD,MAMK;AACD,UAAIG,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAG,CAAtB,EAAyBC,CAAC,GAAGK,EAA7B,KAAoC,CAACF,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAG,CAAtB,EAAyBC,CAAzB,CAAtC,IACCG,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAG,CAAtB,EAAyBC,CAAC,GAAGK,EAA7B,KAAoC,CAACF,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAG,CAAtB,EAAyBC,CAAzB,CADzC,EACuE;AACnE,eAAO,CAACD,CAAD,EAAIC,CAAJ,CAAP;AACH;AACJ;AACJ,GA1CyE,CA4C1E;AACA;;;AACA,MAAIG,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAGK,EAAtB,EAA0BJ,CAA1B,KAAgCG,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAAC,GAAGK,EAAzB,CAApC,EAAkE;AAC9D,WAAO,KAAKP,KAAL,CAAWC,CAAC,GAAGK,EAAf,EAAmBJ,CAAC,GAAGK,EAAvB,EAA2BN,CAA3B,EAA8BC,CAA9B,CAAP;AACH,GAFD,MAEO;AACH,WAAO,IAAP;AACH;AACJ,CAnDD;AAqDA;AACA;AACA;AACA;AACA;AACA;;;AACAP,oCAAoC,CAACG,SAArC,CAA+Ce,cAA/C,GAAgE,UAASC,IAAT,EAAe;AAC3E,MAAIC,MAAM,GAAGD,IAAI,CAACC,MAAlB;AAAA,MACId,CAAC,GAAGa,IAAI,CAACb,CADb;AAAA,MACgBC,CAAC,GAAGY,IAAI,CAACZ,CADzB;AAAA,MAEIG,IAAI,GAAG,KAAKA,IAFhB;AAAA,MAGIF,EAHJ;AAAA,MAGQC,EAHR;AAAA,MAGYY,EAHZ;AAAA,MAGgBC,EAHhB;AAAA,MAGoBX,EAHpB;AAAA,MAGwBC,EAHxB;AAAA,MAIIW,SAAS,GAAG,EAJhB;AAAA,MAIoBC,aAJpB;AAAA,MAImCC,YAJnC;AAAA,MAIiDC,CAJjD;AAAA,MAIoDC,CAJpD,CAD2E,CAO3E;;AACA,MAAIP,MAAJ,EAAY;AACRZ,IAAAA,EAAE,GAAGY,MAAM,CAACd,CAAZ;AACAG,IAAAA,EAAE,GAAGW,MAAM,CAACb,CAAZ,CAFQ,CAGR;;AACAI,IAAAA,EAAE,GAAG,CAACL,CAAC,GAAGE,EAAL,IAAWoB,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAASxB,CAAC,GAAGE,EAAb,CAAT,EAA2B,CAA3B,CAAhB;AACAI,IAAAA,EAAE,GAAG,CAACL,CAAC,GAAGE,EAAL,IAAWmB,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAASvB,CAAC,GAAGE,EAAb,CAAT,EAA2B,CAA3B,CAAhB,CALQ,CAOR;;AACA,QAAIE,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvB,EAA0B;AACtB,UAAIF,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAAC,GAAGK,EAAzB,CAAJ,EAAkC;AAC9BW,QAAAA,SAAS,CAACQ,IAAV,CAAe,CAACzB,CAAD,EAAIC,CAAC,GAAGK,EAAR,CAAf;AACH;;AACD,UAAIF,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAGK,EAAtB,EAA0BJ,CAA1B,CAAJ,EAAkC;AAC9BgB,QAAAA,SAAS,CAACQ,IAAV,CAAe,CAACzB,CAAC,GAAGK,EAAL,EAASJ,CAAT,CAAf;AACH;;AACD,UAAIG,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAAC,GAAGK,EAAzB,KAAgCF,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAGK,EAAtB,EAA0BJ,CAA1B,CAApC,EAAkE;AAC9DgB,QAAAA,SAAS,CAACQ,IAAV,CAAe,CAACzB,CAAC,GAAGK,EAAL,EAASJ,CAAC,GAAGK,EAAb,CAAf;AACH;;AACD,UAAI,CAACF,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAGK,EAAtB,EAA0BJ,CAA1B,CAAD,IAAiCG,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAAC,GAAGK,EAAzB,CAArC,EAAmE;AAC/DW,QAAAA,SAAS,CAACQ,IAAV,CAAe,CAACzB,CAAC,GAAGK,EAAL,EAASJ,CAAC,GAAGK,EAAb,CAAf;AACH;;AACD,UAAI,CAACF,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAAC,GAAGK,EAAzB,CAAD,IAAiCF,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAGK,EAAtB,EAA0BJ,CAA1B,CAArC,EAAmE;AAC/DgB,QAAAA,SAAS,CAACQ,IAAV,CAAe,CAACzB,CAAC,GAAGK,EAAL,EAASJ,CAAC,GAAGK,EAAb,CAAf;AACH;AACJ,KAhBD,CAiBA;AAjBA,SAkBK;AACD,UAAGD,EAAE,KAAK,CAAV,EAAa;AACT,YAAID,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAAC,GAAGK,EAAzB,CAAJ,EAAkC;AAC9BW,UAAAA,SAAS,CAACQ,IAAV,CAAe,CAACzB,CAAD,EAAIC,CAAC,GAAGK,EAAR,CAAf;;AACA,cAAI,CAACF,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAG,CAAtB,EAAyBC,CAAzB,CAAL,EAAkC;AAC9BgB,YAAAA,SAAS,CAACQ,IAAV,CAAe,CAACzB,CAAC,GAAG,CAAL,EAAQC,CAAC,GAAGK,EAAZ,CAAf;AACH;;AACD,cAAI,CAACF,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAG,CAAtB,EAAyBC,CAAzB,CAAL,EAAkC;AAC9BgB,YAAAA,SAAS,CAACQ,IAAV,CAAe,CAACzB,CAAC,GAAG,CAAL,EAAQC,CAAC,GAAGK,EAAZ,CAAf;AACH;AACJ;AACJ,OAVD,MAWK;AACD,YAAIF,IAAI,CAACG,YAAL,CAAkBP,CAAC,GAAGK,EAAtB,EAA0BJ,CAA1B,CAAJ,EAAkC;AAC9BgB,UAAAA,SAAS,CAACQ,IAAV,CAAe,CAACzB,CAAC,GAAGK,EAAL,EAASJ,CAAT,CAAf;;AACA,cAAI,CAACG,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAAC,GAAG,CAAzB,CAAL,EAAkC;AAC9BgB,YAAAA,SAAS,CAACQ,IAAV,CAAe,CAACzB,CAAC,GAAGK,EAAL,EAASJ,CAAC,GAAG,CAAb,CAAf;AACH;;AACD,cAAI,CAACG,IAAI,CAACG,YAAL,CAAkBP,CAAlB,EAAqBC,CAAC,GAAG,CAAzB,CAAL,EAAkC;AAC9BgB,YAAAA,SAAS,CAACQ,IAAV,CAAe,CAACzB,CAAC,GAAGK,EAAL,EAASJ,CAAC,GAAG,CAAb,CAAf;AACH;AACJ;AACJ;AACJ;AACJ,GAlDD,CAmDA;AAnDA,OAoDK;AACDiB,IAAAA,aAAa,GAAGd,IAAI,CAACsB,YAAL,CAAkBb,IAAlB,EAAwBpB,gBAAgB,CAACkC,mBAAzC,CAAhB;;AACA,SAAKP,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGH,aAAa,CAACU,MAA9B,EAAsCR,CAAC,GAAGC,CAA1C,EAA6C,EAAED,CAA/C,EAAkD;AAC9CD,MAAAA,YAAY,GAAGD,aAAa,CAACE,CAAD,CAA5B;AACAH,MAAAA,SAAS,CAACQ,IAAV,CAAe,CAACN,YAAY,CAACnB,CAAd,EAAiBmB,YAAY,CAAClB,CAA9B,CAAf;AACH;AACJ;;AAED,SAAOgB,SAAP;AACH,CArED;;AAuEAY,MAAM,CAACC,OAAP,GAAiBpC,oCAAjB","sourcesContent":["/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\r\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (!grid.isWalkableAt(x + 1, y)) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x - 1, y)) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (!grid.isWalkableAt(x, y + 1)) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x, y - 1)) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n"]},"metadata":{},"sourceType":"script"}
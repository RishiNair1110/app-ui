{"ast":null,"code":"var Util = require('../core/Util');\n\nvar Heuristic = require('../core/Heuristic');\n\nvar Node = require('../core/Node');\n\nvar DiagonalMovement = require('../core/DiagonalMovement');\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\n\n\nfunction IDAStarFinder(opt) {\n  opt = opt || {};\n  this.allowDiagonal = opt.allowDiagonal;\n  this.dontCrossCorners = opt.dontCrossCorners;\n  this.diagonalMovement = opt.diagonalMovement;\n  this.heuristic = opt.heuristic || Heuristic.manhattan;\n  this.weight = opt.weight || 1;\n  this.trackRecursion = opt.trackRecursion || false;\n  this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\n\n  if (!this.diagonalMovement) {\n    if (!this.allowDiagonal) {\n      this.diagonalMovement = DiagonalMovement.Never;\n    } else {\n      if (this.dontCrossCorners) {\n        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n      } else {\n        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n      }\n    }\n  } // When diagonal movement is allowed the manhattan heuristic is not\n  // admissible, it should be octile instead\n\n\n  if (this.diagonalMovement === DiagonalMovement.Never) {\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n  } else {\n    this.heuristic = opt.heuristic || Heuristic.octile;\n  }\n}\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\n\n\nIDAStarFinder.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  // Used for statistics:\n  var nodesVisited = 0; // Execution time limitation:\n\n  var startTime = new Date().getTime(); // Heuristic helper:\n\n  var h = function (a, b) {\n    return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\n  }.bind(this); // Step cost from a to b:\n\n\n  var cost = function (a, b) {\n    return a.x === b.x || a.y === b.y ? 1 : Math.SQRT2;\n  };\n  /**\r\n   * IDA* search implementation.\r\n   *\r\n   * @param {Node} The node currently expanding from.\r\n   * @param {number} Cost to reach the given node.\r\n   * @param {number} Maximum search depth (cut-off value).\r\n   * @param {Array<Array<number>>} The found route.\r\n   * @param {number} Recursion depth.\r\n   *\r\n   * @return {Object} either a number with the new optimal cut-off depth,\r\n   * or a valid node instance, in which case a path was found.\r\n   */\n\n\n  var search = function (node, g, cutoff, route, depth) {\n    nodesVisited++; // Enforce timelimit:\n\n    if (this.timeLimit > 0 && new Date().getTime() - startTime > this.timeLimit * 1000) {\n      // Enforced as \"path-not-found\".\n      return Infinity;\n    }\n\n    var f = g + h(node, end) * this.weight; // We've searched too deep for this iteration.\n\n    if (f > cutoff) {\n      return f;\n    }\n\n    if (node == end) {\n      route[depth] = [node.x, node.y];\n      return node;\n    }\n\n    var min, t, k, neighbour;\n    var neighbours = grid.getNeighbors(node, this.diagonalMovement); // Sort the neighbours, gives nicer paths. But, this deviates\n    // from the original algorithm - so I left it out.\n    //neighbours.sort(function(a, b){\n    //    return h(a, end) - h(b, end);\n    //});\n\n    /*jshint -W084 */\n    //Disable warning: Expected a conditional expression and instead saw an assignment\n\n    for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\n      /*jshint +W084 */\n      //Enable warning: Expected a conditional expression and instead saw an assignment\n      if (this.trackRecursion) {\n        // Retain a copy for visualisation. Due to recursion, this\n        // node may be part of other paths too.\n        neighbour.retainCount = neighbour.retainCount + 1 || 1;\n\n        if (neighbour.tested !== true) {\n          neighbour.tested = true;\n        }\n      }\n\n      t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\n\n      if (t instanceof Node) {\n        route[depth] = [node.x, node.y]; // For a typical A* linked list, this would work:\n        // neighbour.parent = node;\n\n        return t;\n      } // Decrement count, then determine whether it's actually closed.\n\n\n      if (this.trackRecursion && --neighbour.retainCount === 0) {\n        neighbour.tested = false;\n      }\n\n      if (t < min) {\n        min = t;\n      }\n    }\n\n    return min;\n  }.bind(this); // Node instance lookups:\n\n\n  var start = grid.getNodeAt(startX, startY);\n  var end = grid.getNodeAt(endX, endY); // Initial search depth, given the typical heuristic contraints,\n  // there should be no cheaper route possible.\n\n  var cutOff = h(start, end);\n  var j, route, t; // With an overflow protection.\n\n  for (j = 0; true; ++j) {\n    route = []; // Search till cut-off depth:\n\n    t = search(start, 0, cutOff, route, 0); // Route not possible, or not found in time limit.\n\n    if (t === Infinity) {\n      return [];\n    } // If t is a node, it's also the end node. Route is now\n    // populated with a valid path to the end node.\n\n\n    if (t instanceof Node) {\n      return route;\n    } // Try again, this time with a deeper cut-off. The t score\n    // is the closest we got to the end node.\n\n\n    cutOff = t;\n  } // This _should_ never to be reached.\n\n\n  return [];\n};\n\nmodule.exports = IDAStarFinder;","map":{"version":3,"sources":["C:/Users/nairr/app-ui/app-ui/node_modules/pathfinding/src/finders/IDAStarFinder.js"],"names":["Util","require","Heuristic","Node","DiagonalMovement","IDAStarFinder","opt","allowDiagonal","dontCrossCorners","diagonalMovement","heuristic","manhattan","weight","trackRecursion","timeLimit","Infinity","Never","OnlyWhenNoObstacles","IfAtMostOneObstacle","octile","prototype","findPath","startX","startY","endX","endY","grid","nodesVisited","startTime","Date","getTime","h","a","b","Math","abs","x","y","bind","cost","SQRT2","search","node","g","cutoff","route","depth","f","end","min","t","k","neighbour","neighbours","getNeighbors","retainCount","tested","start","getNodeAt","cutOff","j","module","exports"],"mappings":"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","sourcesContent":["var Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar Node       = require('../core/Node');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n"]},"metadata":{},"sourceType":"script"}
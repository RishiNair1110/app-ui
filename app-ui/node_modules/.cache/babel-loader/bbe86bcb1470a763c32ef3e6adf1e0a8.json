{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Polygon = void 0;\n\nconst Point_1 = require(\"./Point\");\n\nconst _ = require(\"lodash\");\n\nclass Polygon {\n  constructor() {\n    let points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    this.points = points;\n  }\n\n  serialize() {\n    return _.map(this.points, point => {\n      return [point.x, point.y];\n    });\n  }\n\n  deserialize(data) {\n    this.points = _.map(data, point => {\n      return new Point_1.Point(point[0], point[1]);\n    });\n  }\n\n  scale(x, y, origin) {\n    let matrix = Point_1.Point.createScaleMatrix(x, y, origin);\n\n    _.forEach(this.points, point => {\n      point.transform(matrix);\n    });\n  }\n\n  transform(matrix) {\n    _.forEach(this.points, point => {\n      point.transform(matrix);\n    });\n  }\n\n  setPoints(points) {\n    this.points = points;\n  }\n\n  getPoints() {\n    return this.points;\n  }\n\n  rotate(degrees) {\n    this.transform(Point_1.Point.createRotateMatrix(degrees / (180 / Math.PI), this.getOrigin()));\n  }\n\n  translate(offsetX, offsetY) {\n    _.forEach(this.points, point => {\n      point.translate(offsetX, offsetY);\n    });\n  }\n\n  doClone(ob) {\n    this.points = _.map(ob.points, point => {\n      return point.clone();\n    });\n  }\n\n  clone() {\n    let ob = Object.create(this);\n    ob.doClone(this);\n    return ob;\n  }\n\n  getOrigin() {\n    if (this.points.length === 0) {\n      return null;\n    }\n\n    let dimensions = this.getBoundingBox();\n    return Point_1.Point.middlePoint(dimensions.getTopLeft(), dimensions.getBottomRight());\n  }\n\n  static boundingBoxFromPolygons(polygons) {\n    return Polygon.boundingBoxFromPoints(_.flatMap(polygons, polygon => {\n      return polygon.getPoints();\n    }));\n  }\n\n  static boundingBoxFromPoints(points) {\n    if (points.length === 0) {\n      return new Rectangle_1.Rectangle(0, 0, 0, 0);\n    }\n\n    let minX = points[0].x;\n    let maxX = points[0].x;\n    let minY = points[0].y;\n    let maxY = points[0].y;\n\n    for (let i = 1; i < points.length; i++) {\n      if (points[i].x < minX) {\n        minX = points[i].x;\n      }\n\n      if (points[i].x > maxX) {\n        maxX = points[i].x;\n      }\n\n      if (points[i].y < minY) {\n        minY = points[i].y;\n      }\n\n      if (points[i].y > maxY) {\n        maxY = points[i].y;\n      }\n    }\n\n    return new Rectangle_1.Rectangle(new Point_1.Point(minX, minY), new Point_1.Point(maxX, minY), new Point_1.Point(maxX, maxY), new Point_1.Point(minX, maxY));\n  }\n\n  getBoundingBox() {\n    let minX = this.points[0].x;\n    let maxX = this.points[0].x;\n    let minY = this.points[0].y;\n    let maxY = this.points[0].y;\n\n    for (let i = 1; i < this.points.length; i++) {\n      if (this.points[i].x < minX) {\n        minX = this.points[i].x;\n      }\n\n      if (this.points[i].x > maxX) {\n        maxX = this.points[i].x;\n      }\n\n      if (this.points[i].y < minY) {\n        minY = this.points[i].y;\n      }\n\n      if (this.points[i].y > maxY) {\n        maxY = this.points[i].y;\n      }\n    }\n\n    return new Rectangle_1.Rectangle(new Point_1.Point(minX, minY), new Point_1.Point(maxX, minY), new Point_1.Point(maxX, maxY), new Point_1.Point(minX, maxY));\n  }\n\n}\n\nexports.Polygon = Polygon;\n\nconst Rectangle_1 = require(\"./Rectangle\");","map":{"version":3,"mappings":"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","names":["Polygon","constructor","points","serialize","_","map","point","x","y","deserialize","data","Point_1","scale","origin","matrix","createScaleMatrix","forEach","transform","setPoints","getPoints","rotate","degrees","createRotateMatrix","Math","PI","getOrigin","translate","offsetX","offsetY","doClone","ob","clone","Object","create","length","dimensions","getBoundingBox","middlePoint","getTopLeft","getBottomRight","boundingBoxFromPolygons","polygons","boundingBoxFromPoints","flatMap","polygon","Rectangle_1","minX","maxX","minY","maxY","i","exports"],"sources":["C:\\Users\\nairr\\app-ui\\app-ui\\node_modules\\@projectstorm\\geometry\\src\\Polygon.ts"],"sourcesContent":["import { Point } from './Point';\nimport * as _ from 'lodash';\nimport { Matrix } from './Matrix';\n\nexport class Polygon {\n\tprotected points: Point[];\n\n\tconstructor(points: Point[] = []) {\n\t\tthis.points = points;\n\t}\n\n\tserialize() {\n\t\treturn _.map(this.points, (point) => {\n\t\t\treturn [point.x, point.y];\n\t\t});\n\t}\n\n\tdeserialize(data: any) {\n\t\tthis.points = _.map(data, (point) => {\n\t\t\treturn new Point(point[0], point[1]);\n\t\t});\n\t}\n\n\tscale(x, y, origin: Point) {\n\t\tlet matrix = Point.createScaleMatrix(x, y, origin);\n\t\t_.forEach(this.points, (point) => {\n\t\t\tpoint.transform(matrix);\n\t\t});\n\t}\n\n\ttransform(matrix: Matrix) {\n\t\t_.forEach(this.points, (point) => {\n\t\t\tpoint.transform(matrix);\n\t\t});\n\t}\n\n\tsetPoints(points: Point[]) {\n\t\tthis.points = points;\n\t}\n\n\tgetPoints(): Point[] {\n\t\treturn this.points;\n\t}\n\n\trotate(degrees: number) {\n\t\tthis.transform(Point.createRotateMatrix(degrees / (180 / Math.PI), this.getOrigin()));\n\t}\n\n\ttranslate(offsetX: number, offsetY: number) {\n\t\t_.forEach(this.points, (point) => {\n\t\t\tpoint.translate(offsetX, offsetY);\n\t\t});\n\t}\n\n\tdoClone(ob: this) {\n\t\tthis.points = _.map(ob.points, (point) => {\n\t\t\treturn point.clone();\n\t\t});\n\t}\n\n\tclone(): this {\n\t\tlet ob = Object.create(this);\n\t\tob.doClone(this);\n\t\treturn ob;\n\t}\n\n\tgetOrigin(): Point {\n\t\tif (this.points.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tlet dimensions = this.getBoundingBox();\n\t\treturn Point.middlePoint(dimensions.getTopLeft(), dimensions.getBottomRight());\n\t}\n\n\tstatic boundingBoxFromPolygons(polygons: Polygon[]): Rectangle {\n\t\treturn Polygon.boundingBoxFromPoints(\n\t\t\t_.flatMap(polygons, (polygon) => {\n\t\t\t\treturn polygon.getPoints();\n\t\t\t})\n\t\t);\n\t}\n\n\tstatic boundingBoxFromPoints(points: Point[]): Rectangle {\n\t\tif (points.length === 0) {\n\t\t\treturn new Rectangle(0, 0, 0, 0);\n\t\t}\n\n\t\tlet minX = points[0].x;\n\t\tlet maxX = points[0].x;\n\t\tlet minY = points[0].y;\n\t\tlet maxY = points[0].y;\n\n\t\tfor (let i = 1; i < points.length; i++) {\n\t\t\tif (points[i].x < minX) {\n\t\t\t\tminX = points[i].x;\n\t\t\t}\n\t\t\tif (points[i].x > maxX) {\n\t\t\t\tmaxX = points[i].x;\n\t\t\t}\n\t\t\tif (points[i].y < minY) {\n\t\t\t\tminY = points[i].y;\n\t\t\t}\n\t\t\tif (points[i].y > maxY) {\n\t\t\t\tmaxY = points[i].y;\n\t\t\t}\n\t\t}\n\n\t\treturn new Rectangle(new Point(minX, minY), new Point(maxX, minY), new Point(maxX, maxY), new Point(minX, maxY));\n\t}\n\n\tgetBoundingBox(): Rectangle {\n\t\tlet minX = this.points[0].x;\n\t\tlet maxX = this.points[0].x;\n\t\tlet minY = this.points[0].y;\n\t\tlet maxY = this.points[0].y;\n\n\t\tfor (let i = 1; i < this.points.length; i++) {\n\t\t\tif (this.points[i].x < minX) {\n\t\t\t\tminX = this.points[i].x;\n\t\t\t}\n\t\t\tif (this.points[i].x > maxX) {\n\t\t\t\tmaxX = this.points[i].x;\n\t\t\t}\n\t\t\tif (this.points[i].y < minY) {\n\t\t\t\tminY = this.points[i].y;\n\t\t\t}\n\t\t\tif (this.points[i].y > maxY) {\n\t\t\t\tmaxY = this.points[i].y;\n\t\t\t}\n\t\t}\n\n\t\treturn new Rectangle(new Point(minX, minY), new Point(maxX, minY), new Point(maxX, maxY), new Point(minX, maxY));\n\t}\n}\n\nimport { Rectangle } from './Rectangle';\n"]},"metadata":{},"sourceType":"script"}
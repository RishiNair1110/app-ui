{"ast":null,"code":"var Util = require('../core/Util');\n\nvar DiagonalMovement = require('../core/DiagonalMovement');\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\n\n\nfunction BiBreadthFirstFinder(opt) {\n  opt = opt || {};\n  this.allowDiagonal = opt.allowDiagonal;\n  this.dontCrossCorners = opt.dontCrossCorners;\n  this.diagonalMovement = opt.diagonalMovement;\n\n  if (!this.diagonalMovement) {\n    if (!this.allowDiagonal) {\n      this.diagonalMovement = DiagonalMovement.Never;\n    } else {\n      if (this.dontCrossCorners) {\n        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n      } else {\n        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n      }\n    }\n  }\n}\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\n\n\nBiBreadthFirstFinder.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  var startNode = grid.getNodeAt(startX, startY),\n      endNode = grid.getNodeAt(endX, endY),\n      startOpenList = [],\n      endOpenList = [],\n      neighbors,\n      neighbor,\n      node,\n      diagonalMovement = this.diagonalMovement,\n      BY_START = 0,\n      BY_END = 1,\n      i,\n      l; // push the start and end nodes into the queues\n\n  startOpenList.push(startNode);\n  startNode.opened = true;\n  startNode.by = BY_START;\n  endOpenList.push(endNode);\n  endNode.opened = true;\n  endNode.by = BY_END; // while both the queues are not empty\n\n  while (startOpenList.length && endOpenList.length) {\n    // expand start open list\n    node = startOpenList.shift();\n    node.closed = true;\n    neighbors = grid.getNeighbors(node, diagonalMovement);\n\n    for (i = 0, l = neighbors.length; i < l; ++i) {\n      neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      if (neighbor.opened) {\n        // if this node has been inspected by the reversed search,\n        // then a path is found.\n        if (neighbor.by === BY_END) {\n          return Util.biBacktrace(node, neighbor);\n        }\n\n        continue;\n      }\n\n      startOpenList.push(neighbor);\n      neighbor.parent = node;\n      neighbor.opened = true;\n      neighbor.by = BY_START;\n    } // expand end open list\n\n\n    node = endOpenList.shift();\n    node.closed = true;\n    neighbors = grid.getNeighbors(node, diagonalMovement);\n\n    for (i = 0, l = neighbors.length; i < l; ++i) {\n      neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      if (neighbor.opened) {\n        if (neighbor.by === BY_START) {\n          return Util.biBacktrace(neighbor, node);\n        }\n\n        continue;\n      }\n\n      endOpenList.push(neighbor);\n      neighbor.parent = node;\n      neighbor.opened = true;\n      neighbor.by = BY_END;\n    }\n  } // fail to find the path\n\n\n  return [];\n};\n\nmodule.exports = BiBreadthFirstFinder;","map":{"version":3,"sources":["C:/Users/nairr/app-ui/app-ui/node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js"],"names":["Util","require","DiagonalMovement","BiBreadthFirstFinder","opt","allowDiagonal","dontCrossCorners","diagonalMovement","Never","OnlyWhenNoObstacles","IfAtMostOneObstacle","prototype","findPath","startX","startY","endX","endY","grid","startNode","getNodeAt","endNode","startOpenList","endOpenList","neighbors","neighbor","node","BY_START","BY_END","i","l","push","opened","by","length","shift","closed","getNeighbors","biBacktrace","parent","module","exports"],"mappings":"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","sourcesContent":["var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n"]},"metadata":{},"sourceType":"script"}